---
title: "IOF_EOF_ORAS"
author: "Ryan Peterson"
date: "2025-08-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
#.nc files
suppressMessages(library(ncdf4))
suppressMessages(library(terra))

# date/data mgmt
suppressMessages(library(lubridate))
suppressMessages(library(abind))

#visualization and interpolation
suppressMessages(library(fields))
suppressMessages(library(colorspace))
suppressMessages(library(RColorBrewer))
suppressMessages(library(scales)) #for adjusting opacity
```

```{r import}
#import some of the associated data
setwd("~/CO_AUS/Aus_CO-main")

#ORAS5
##1982
#sept 1982
nc.ORAS.1982S <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_198209_CONS_v0.1.nc")
#oct 1982
nc.ORAS.1982o <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_198210_CONS_v0.1.nc")
#nov 1982
nc.ORAS.1982n <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_198211_CONS_v0.1.nc")

##1983
#sept 1983

```

```{r load_ins}
setwd("~/CO_AUS/Aus_CO-main/pIOD")
load("sst_base.rda") #mostly for the lon.values and lat.values
```

```{r functions}
array_setup <- function(nc.data, wide.lon, wide.lat){

  
  #lon/lat matrices [nx, ny] ([lon, lat])
  get.lat <- ncvar_get(nc.data, "nav_lat")
  get.lon <- ncvar_get(nc.data, "nav_lon")
  
  #get sst data
  sst.oras <- ncvar_get(nc.data, "sosstsst")
  
  iod.mask <- get.lat >= wide.lat[1] & get.lat <= wide.lat[2] &
          get.lon >= wide.lon[1] & get.lon <= wide.lon[2]
  
  lat.in <- get.lat[iod.mask]
  lon.in <- get.lon[iod.mask]
  sst.oras.in <- sst.oras[iod.mask]
  
  return(list(lon = lon.in,
              lat = lat.in,
              sst = sst.oras.in))
}


reformat_interpolate <- function(lon.in, lat.in, sst.oras.in, 
                                 grid.list){
  #reformat 
  n <- length(lon.in) /363
  
  seq.list <- split(1:59169, ceiling(seq_along(1:59169) / 363))
  
  #take chunk of 363 reorder, and remove duplicate data manually
  new.order <- c(191:363, 3:190)
  
  #TODO: setup additional matrix just for the sst data
  sst.mat <- matrix(NA, ncol = 3)
  colnames(sst.mat) < c("lon", "lat", "sst")
  for (i in 1:n) {
    lon.temp <- lon.in[seq.list[[i]]]
    lat.temp <- lat.in[seq.list[[i]]]
    sst.temp <- sst.oras.in[seq.list[[i]]]
    
    #temporary matrix setup
    temp.mat <- cbind(lon = lon.temp[new.order], 
                      lat = lat.temp[new.order], 
                      sst = sst.temp[new.order])
    
    sst.mat <- rbind(sst.mat, temp.mat)
  }
  
  sst.df <- as.data.frame(sst.mat[-1,])
  
  get.x <- unique(sst.df$lon)
  get.y <- unique(sst.df$lat)
  
  sst.oras.matrix <- matrix(sst.df$sst, nrow = 361)
  
  #interpolate

  obj.oras <- list(x = get.x, y = get.y, z = sst.oras.matrix)
  
  out.interp <- interp.surface.grid(obj.oras, grid.list) #not currently working (duplicated data)

  return(out.interp$z)
}

```


```{r data_clean}

#wide, reduced boundary (Indian Ocean)
wide_maxLon <- 120
wide_minLon <- 30
wide_maxLat <- 20
wide_minLat <- -20

wide.lon <- c(wide_minLon, wide_maxLon)
wide.lat <- c(wide_minLat, wide_maxLat)

#lon/lat matrices [nx, ny] ([lon, lat])
get.lat <- ncvar_get(nc.ORAS.1982S, "nav_lat")
get.lon <- ncvar_get(nc.ORAS.1982S, "nav_lon")

#get sst data
sst.oras <- ncvar_get(nc.ORAS.1982S, "sosstsst")

iod.mask <- get.lat >= wide_minLat & get.lat <= wide_maxLat &
        get.lon >= wide_minLon & get.lon <= wide_maxLon

lat.in <- get.lat[iod.mask]
lon.in <- get.lon[iod.mask]
sst.oras.in <- sst.oras[iod.mask]

#setup gridlist
grid.list <- list(x = lon.values,
                  y = rev(lat.values))



```



```{r TESTdata_clean}
#TODO: explore the data to see how we need to prep it

#wide, reduced boundary (Indian Ocean)
wide_maxLon <- 120
wide_minLon <- 30
wide_maxLat <- 20
wide_minLat <- -20

lon.range <- c(wide_minLon, wide_maxLon)
lat.range <- c(wide_minLat, wide_maxLat)

#TODO: functionalize this since we will have a lot of individual files.

#lon/lat matrices [nx, ny] ([lon, lat])
get.lat <- ncvar_get(nc.ORAS.1982S, "nav_lat")
get.lon <- ncvar_get(nc.ORAS.1982S, "nav_lon")

#get sst data
sst.oras <- ncvar_get(nc.ORAS.1982S, "sosstsst")

iod.mask <- get.lat >= wide_minLat & get.lat <= wide_maxLat &
        get.lon >= wide_minLon & get.lon <= wide_maxLon

lat.in <- get.lat[iod.mask]
lon.in <- get.lon[iod.mask]
sst.oras.in <- sst.oras[iod.mask]

#reformat 
n <- length(lon.in) /363

seq.list <- split(1:59169, ceiling(seq_along(1:59169) / 363))

#take chunk of 363 reorder, and remove duplicate data manually
new.order <- c(191:363, 3:190)

#TODO: setup additional matrix just for the sst data
sst.mat <- matrix(NA, ncol = 3)
colnames(sst.mat) < c("lon", "lat", "sst")
for (i in 1:n) {
  lon.temp <- lon.in[seq.list[[i]]]
  lat.temp <- lat.in[seq.list[[i]]]
  sst.temp <- sst.oras.in[seq.list[[i]]]
  
  #temporary matrix setup
  temp.mat <- cbind(lon = lon.temp[new.order], 
                    lat = lat.temp[new.order], 
                    sst = sst.temp[new.order])
  
  sst.mat <- rbind(sst.mat, temp.mat)
}

sst.df <- as.data.frame(sst.mat[-1,])

get.x <- unique(sst.df$lon)
get.y <- unique(sst.df$lat)

sst.oras.matrix <- matrix(sst.df$sst, nrow = 361)

#note the correction here is just to interp to a grid
grid.list <- list(x = lon.values,
                  y = rev(lat.values))
obj.oras <- list(x = get.x, y = get.y, z = sst.oras.matrix)

out.interp <- interp.surface.grid(obj.oras, grid.list) #not currently working (duplicated data)

#test output
image.plot(list(x=lon.values, y=rev(lat.values), z=out.interp$z),
           col = ryb_col, breaks = brks)
world(add = TRUE)

 
#TODO: finalize the interpolation to a grid then funcationalize and run through SST anoms


#interpolation example code for SODA3.3.1
sst.interp.SODA <- NULL
for (i in 1:dim(sst.soda.new)[3]) {
  base.obj <- list(x = lon.values.soda, y = rev(lat.values.soda), z = sst.soda.new[,,i])

  grid.list <- list(x = lon.values,
                    y = lat.values)
  
  out.interp <- interp.surface.grid(base.obj, grid.list)
  
  interp.mat <- out.interp$z[ ,ncol(out.interp$z):1 ]
  
  sst.interp.SODA <- abind(sst.interp.SODA, interp.mat, along = 3)
}




as.index <- which(iod.mask, arr.ind = TRUE)
sst.oras.mat <- sst.oras[as.index]
```

```{r temp_clean}
#TODO: re-sort everything to get the correct order since these are fucked!
n <- length(lon.in) /363

seq.list <- split(1:59169, ceiling(seq_along(1:59169) / 363))

#test run for seq.list and individual 
#seq.list[[1]]
lon.test <- lon.in[seq.list[[1]]]
lat.test <- lat.in[seq.list[[1]]]
sst.test <- sst.oras.in[seq.list[[1]]]

test.mat <- cbind(lon = lon.test[new.order], 
                     lat = lat.test[new.order], 
                     sst = sst.oras.in[new.order])

#take chunk of 363 reorder, and remove duplicate data manually
new.order <- c(191:363, 3:190)

#TODO: setup additional matrix just for the sst data
sst.mat <- matrix(NA, ncol = 3)
colnames(sst.mat) < c("lon", "lat", "sst")
for (i in 1:n) {
  lon.temp <- lon.in[seq.list[[i]]]
  lat.temp <- lat.in[seq.list[[i]]]
  sst.temp <- sst.oras.in[seq.list[[i]]]
  
  #temporary matrix setup
  temp.mat <- cbind(lon = lon.temp[new.order], 
                    lat = lat.temp[new.order], 
                    sst = sst.temp[new.order])
  
  sst.mat <- rbind(sst.mat, temp.mat)
}

sst.df <- as.data.frame(sst.mat[-1,])

get.x <- unique(sst.df$lon)
get.y <- unique(sst.df$lat)

sst.oras.matrix <- matrix(sst.df$sst, nrow = 361)

oras.max <-max(sst.oras.matrix, na.rm = TRUE)
ryb_col <- rev(divergingx_hcl(n = 18, palette = "RdYlBu"))
brks <- c(-2:0, 4, 8, 12, 16, 20:30, oras.max)


image.plot(list(x=get.x, y=get.y, z=sst.oras.matrix),
           col = ryb_col, breaks = brks)
world(add = TRUE)
```



```{r temp_interp}
#for getting the interp surface working with the ORAS data

#this issue might be in all the na data at lower lon values,
## use other data product to figure out when the NAs stop
test.sst <- sst.array[,,1]

#note the correction here is just to interp to a grid
grid.list <- list(x = lon.values,
                  y = rev(lat.values))
obj.oras <- list(x = lon.new, y = rev(lat.new), z = sst.oras.new)

out.interp <- interp.surface.grid(obj.oras, grid.list) #not currently working (duplicated data)

#temp work on interp surface grid, delete when fixed
x <- grid.list$x
length(unique(x))
y <- grid.list$y
M <- length(x)
N <- length(y)
out <- matrix(NA, nrow = M, ncol = N)
ncol(out)

test.new <- cbind(rep(x[i], N), y)

i <- 5
out[i,] <- interp.surface(obj.oras, cbind(rep(x[i], N), y)) 
length(interp.surface(obj.oras, cbind(rep(x[i], N), y))) #produces 80 instead of 40

#internals of interp.surface
obj <- obj.oras
loc <- cbind(rep(x[i], N), y)

x <- obj$x
range(x)

y <- obj$y
length(y)
range(y)

z <- obj$z
nx <- length(x)
ny <- length(y)

length(loc[, 1])

lx <- approx(x, 1:nx, loc[, 1])$y
ly <- approx(y, 1:ny, loc[, 2])$y
lx1 <- floor(lx)
ly1 <- floor(ly)



x[lx1]
y[ly1]

cbind(lx1, ly1)
z[cbind(lx1, ly1)]

ex <- lx - lx1
ey <- ly - ly1

ex[lx1 == nx] <- 1
ey[ly1 == ny] <- 1
lx1[lx1 == nx] <- nx - 1
ly1[ly1 == ny] <- ny - 1



z[cbind(lx1, ly1)] * (1 - ex) * (1 - ey) + z[cbind(lx1 + 
        1, ly1)] * ex * (1 - ey) + z[cbind(lx1, ly1 + 1)] * (1 - 
        ex) * ey + z[cbind(lx1 + 1, ly1 + 1)] * ex * ey

```



```{r test_viz}
#for testing the visualization of a single month and year. 

quilt.plot(lon.in, lat.in, sst.oras.in, zlim = c(20, 31))
world(add= TRUE)


image(get.lon, rev(get.lat), iod.mask, col = c("white", "steelblue"),
      xlim = c(30, 120), ylim = c(-20,20))
world(add= TRUE)
```




