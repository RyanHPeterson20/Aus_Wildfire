---
title: "IOD_EOF_test"
author: "Ryan Peterson"
date: "2025-08-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
#.nc files
library(ncdf4)
suppressMessages(library(terra))

# date mgmt
suppressMessages(library(lubridate))

#visualization and interpolation
suppressMessages(library(fields))

```


Reproducing with all four reanalysis products

```{r import_data}
setwd("~/CO_AUS/Aus_CO-main")

#lots of stuff here, keep minimized when done.

#begin easy with monthly OISST
nc.OISS.month <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sst.mnmean.nc")

#OISST land sea mask
nc.OISS.lsm <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/lsmask.nc")

#GODAS monthly
#TODO: move to separate code block
#1980 (by year)
nc.GODASsshg.1980 <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sshg.1980.nc") #sea surface height

#1980 
nc.GODAS.1980 <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/pottmp.1980.nc")

#1982
nc.GODAS.1982 <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/pottmp.1982.nc")


#ORAS5
#TODO: move to separate code block
#sept 1979
nc.ORAS.1979S <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_197909_CONS_v0.1.nc")


##SODA3.3.1
#all monthly data in a single file
nc.SODA.month <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/erdSoda331oceanmday_6a77_2294_0698.nc")

```


```{r GODAS_import}

#GODAS yearly (1982-2015)

```


```{r ORAS_import}

#ORAS5
#sept 1979 (test section)
nc.ORAS.1979S <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_197909_CONS_v0.1.nc")

#jan 1982
nc.ORAS.198201 <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/ORAS5/sosstsst_control_monthly_highres_2D_198201_CONS_v0.1.nc")




```



# Data Cleaning

OISS cleaning (simple)

```{r OISST}
#extract lon, lat
lat.grid <- nc.OISS.month[["dim"]][["lat"]][["vals"]]
lon.grid <- nc.OISS.month[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid[lon.grid >= 180] <- lon.grid[lon.grid >= 180] - 360
this.order <- order(lon.grid)

lon.grid <- lon.grid[this.order]

#time data
times <- ncvar_get(nc.OISS.month, "time") # days since 1800-01-01 00:00:0.0
times <- as_datetime("1800-01-01T00:00:00") + days(times)

#sst data, as array (lon, lat, time)
sst.oisst <- ncvar_get(nc.OISS.month, "sst")
sst.oisst <- sst.oisst[this.order, , ]

```



```{r GODAS}
#TODO: repeat for all year, start with 1982 to 2015

#for single month
lat.grid.godas <- nc.GODAS.1982[["dim"]][["lat"]][["vals"]]
lon.grid.godas <- nc.GODAS.1982[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.godas[lon.grid.godas >= 180] <- lon.grid.godas[lon.grid.godas >= 180] - 360
lon.order.godas <- order(lon.grid.godas)

lon.grid.godas <- lon.grid.godas[lon.order.godas]

#reorder lat
lat.order.godas <- order(lat.grid.godas, decreasing = TRUE)
lat.grid.godas <- lat.grid.godas[lat.order.godas]

#times for months
times.godas <- ncvar_get(nc.GODAS.1982, "time") # days since 1800-01-01 00:00:0.0
times.godas <- as_datetime("1800-01-01T00:00:00") + days(times.godas)

#temps, as array (lon, lat, level, time)
#TODO adjust from K to c (K - 273.15)
sst.godas <- ncvar_get(nc.GODAS.1982, "pottmp")
sst.godas <- sst.godas[lon.order.godas, lat.order.godas, 1, ] #level: depth 5m
```


```{r ORAS5}
#for single month
#TODO: delete later once we get the location matrix set-up correctly
lat.grid.oras <- nc.ORAS.198201[["dim"]][["y"]][["vals"]]
lon.grid.oras <- nc.ORAS.198201[["dim"]][["x"]][["vals"]]

length(lat.grid.oras)
length(lon.grid.oras)

get.lat <- ncvar_get(nc.ORAS.198201, "nav_lat")
get.lon <- ncvar_get(nc.ORAS.198201, "nav_lon")

#adjust lon/lat, (I think they need to be flipped) We might need to find the max first, if the rows are not consistent
get.lat.new <- get.lat[c(431:nrow(get.lat), 1:430), ncol(get.lat):1]
get.lon.new <- get.lon[c(431:nrow(get.lon), 1:430), ncol(get.lon):1]
  
#TODO: use the above lon,lat values for selecting for subset
#try as lon,lat columns:
oras.loc <- cbind(as.vector(get.lon.new), as.vector(get.lat.new))
colnames(oras.loc) <- c("lon", "lat")

#TODO: create large matrix of tuples (x,y); since we are given a matrix of lon X lat that aligns with the data 

#get sst data
sst.osar <- ncvar_get(nc.ORAS.198201, "sosstsst")
sst.osar <- sst.osar[c(431:nrow(sst.osar), 1:430), ncol(sst.osar):1]
sst.osar.vec <- as.vector(sst.osar)

```


```{r SODA}
#for monthly
lat.grid.soda <- nc.SODA.month[["dim"]][["latitude"]][["vals"]]
lon.grid.soda <- nc.SODA.month[["dim"]][["longitude"]][["vals"]]

#adjust lon order
lon.grid.soda[lon.grid.soda >= 180] <- lon.grid.soda[lon.grid.soda >= 180] - 360
lon.order.soda <- order(lon.grid.soda)

lon.grid.soda <- lon.grid.soda[lon.order.soda]

#adjust lat order
#TODO: double check this, it might be wrong
lat.order.soda <- order(lat.grid.soda, decreasing = TRUE)
lat.grid.soda <- lat.grid.soda[lat.order.soda]

#get times
times.soda <- ncvar_get(nc.SODA.month, "time") #seconds since 1970-01-01T00:00:00Z
times.soda <- as_datetime("1970-01-01T00:00:00") + seconds(times.soda)
  
  
sst.soda <- ncvar_get(nc.SODA.month, "temp")
sst.soda <- sst.soda[lon.order.soda, lat.order.soda, ]

```


# Grid Fill

Fill in data to match each other (look at reduced range of Indian Ocean)
lat: (-20, 20)
lon: (30, 180)

```{r select}
#set larger boundary (for comparison)
wide_maxLon <- 110
wide_minLon <- 30
wide_maxLat <- 20
wide_minLat <- -20

wide.lon.range <- c(wide_minLon, wide_maxLon)
wide.lat.range <- c(wide_minLat, wide_maxLat)

#get value in the boundary range

#OISST range
lat.values <- lat.grid[lat.grid <= wide_maxLat & lat.grid >= wide_minLat]
lat.range <- range(which(lat.grid <= wide_maxLat & lat.grid >= wide_minLat))

lon.values <- lon.grid[lon.grid <= wide_maxLon & lon.grid >= wide_minLon]
lon.range <- range(which(lon.grid <= wide_maxLon & lon.grid >= wide_minLon))

#get OISST SST reduced matrix
sst_OISST <- sst[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2], 2]  #january 1982
sst.OISST.new <- sst_OISST[,ncol(sst_OISST):1]


#GODAS range
lat.values.godas <- lat.grid.godas[lat.grid.godas <= wide_maxLat & lat.grid.godas >= wide_minLat]

lat.range.godas <- range(which(lat.grid.godas <= wide_maxLat & lat.grid.godas >= wide_minLat))

lon.values.godas <- lon.grid.godas[lon.grid.godas <= wide_maxLon & lon.grid.godas >= wide_minLon]
lon.range.godas <- range(which(lon.grid.godas <= wide_maxLon & lon.grid.godas >= wide_minLon))

#get GODAS SST reduced matrix (already masked)
sst_GODAS <- sst.godas[lon.range.godas[1]:lon.range.godas[2], lat.range.godas[1]:lat.range.godas[2], 1] #january 1982
sst.godas.new <- sst_GODAS - 273.15
z_godas <- range(sst.godas.new, na.rm = TRUE)
sst.godas.new <- sst.godas.new[, ncol(sst.godas.new):1]



#SODA range
lat.values.soda <- lat.grid.soda[lat.grid.soda <= wide_maxLat & lat.grid.soda >= wide_minLat]
lat.range.soda <- range(which(lat.grid.soda <= wide_maxLat & lat.grid.soda >= wide_minLat))

lon.values.soda <- lon.grid.soda[lon.grid.soda <= wide_maxLon & lon.grid.soda >= wide_minLon]
lon.range.soda <- range(which(lon.grid.soda <= wide_maxLon & lon.grid.soda >= wide_minLon))


#get SODA SST reduced matrix 
sst_soda <- sst.soda[lon.range.soda[1]:lon.range.soda[2], lat.range.soda[1]:lat.range.soda[2], 25]
sst.soda.new <- sst_soda[,ncol(sst_soda):1]


z_soda <- range(sst_soda, na.rm = TRUE)

times.soda[25]
```


```{r oras_select}
#TODO: update to function
in_bounds <- oras.loc[, "lon"] >= wide_minLon &
             oras.loc[, "lon"] <= wide_maxLon &
             oras.loc[, "lat"] >= wide_minLat &
             oras.loc[, "lat"] <= wide_maxLat

which_pts <- which(in_bounds)

oras.loc.red <- oras.loc[in_bounds, , drop = FALSE]


length(oras.loc.red[,"lon"])
v.lon <- oras.loc.red[,"lon"]
v.lat <- oras.loc.red[,"lat"]

non_increasing <- diff(v.lon) <= 0
which(non_increasing)

#get unique values
unique.lon <- unique(oras.loc.red[,"lon"]) #nrow 
unique.lat <- unique(oras.loc.red[,"lat"]) #ncol

#reproduce the get.lon matrix then find is.na locations
get.lon.index <- seq_along(as.vector(get.lon.new))
get.lon.bounds <- get.lon.index[in_bounds]

get.lon.mask <- matrix(NA, nrow = nrow(get.lon.new), ncol = ncol(get.lon.new))
get.lon.mask[get.lon.bounds] <- as.vector(get.lon.new)[get.lon.bounds]

test_lon <- !is.na(get.lon.mask)
row_keep <- apply(test_lon, 1, any)  
col_keep <- apply(test_lon, 2, any)  

get.lon_test <- get.lon.mask[row_keep, col_keep]

sst.osar.red <- sst.osar[row_keep, col_keep]



##sort lon/lat for image.plot
lon_vals <- sort(as.vector(oras.loc.red[,"lon"]))
lat_vals <- sort(as.vector(oras.loc.red[,"lat"]))

sst.osar.plot <- sst.osar.red[order(lon_vals), order(lat_vals)]


#get matrix adjustments
sst.osar.index <- seq_along(as.vector(sst.osar))
sst.osar.bounds <- sst.osar.index[in_bounds]

sst.osar.mask <- matrix(NA, nrow = nrow(sst.osar), ncol = ncol(sst.osar))
sst.osar.mask[sst.osar.bounds] <- as.vector(sst.osar)[sst.osar.bounds]


#sst.osar.red <- as.matrix(sst.osar.vec[in_bounds], nrow = length(unique.lon), ncol = length(unique.lat))

```

```{r osar_fig}
image.plot(list(x = oras.loc.red[,"lon"], y = rev(oras.loc.red[,"lat"]), z = sst.osar.red), 
           col = tim.colors(256), zlim = z_temp, 
           xlab = "Lon", ylab = "Lat", main = paste0("SODA: ", format(as.Date(times.soda[25]), "%B %Y")))
world(add=TRUE)
```



```{r LS-mask}
#extract lon, lat
lat.grid.lsm <- nc.OISS.lsm[["dim"]][["lat"]][["vals"]]
lon.grid.lsm <- nc.OISS.lsm[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.lsm[lon.grid.lsm >= 180] <- lon.grid.lsm[lon.grid.lsm >= 180] - 360
this.order.lsm <- order(lon.grid.lsm)

lon.grid.lsm <- lon.grid.lsm[this.order.lsm]


#setup (or find) a land sea mask.
lsm <- ncvar_get(nc.OISS.lsm, "mask")
lsm <- lsm[this.order.lsm, ]

#TODO update lsm for reduced region
#get lsm for IOD only
lsm_IOD <- lsm[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2]] 
```


```{r month_select}
sst.OISST.new <- sst.OISST.new* lsm_IOD[ ,ncol(lsm_IOD):1]
```


```{r test_figures}
z_temp <- range(sst_OISST, sst_soda, sst.godas.new, na.rm = TRUE)

image.plot(list(x = lon.values, y = rev(lat.values), z = sst.OISST.new), col = tim.colors(256), zlim = z_temp, 
           xlab = "Lon", ylab = "Lat", main = paste0("OISST: ", format(as.Date(times[2]), "%B %Y")))
world(add=TRUE)

#GODAS plot 
#TODO: inspect the data cleaning, the data seems "wrong"
image.plot(list(x = lon.values.godas, y = rev(lat.values.godas), z = sst.godas.new), col = tim.colors(256), zlim = z_temp, 
           xlab = "Lon", ylab = "Lat", main = paste0("GODAS: ", format(as.Date(times.godas[1]), "%B %Y")))
world(add=TRUE)

image.plot(list(x = lon.values.soda, y = rev(lat.values.soda), z = sst.soda.new), col = tim.colors(256), zlim = z_temp, 
           xlab = "Lon", ylab = "Lat", main = paste0("SODA: ", format(as.Date(times.soda[25]), "%B %Y")))
world(add=TRUE)


#TODO: currently not working
image.plot(list(x = lon.bound.new, y = lat.bound.new, z = sst.OISST.new), 
           col = tim.colors(256), zlim = z_temp, 
           xlab = "Lon", ylab = "Lat", main = paste0("SODA: ", format(as.Date(times.soda[25]), "%B %Y")))
world(add=TRUE)

```


```{r grid}
#OISST (grid locations), get 
lat.grid
lon.grid

#GODAS


#SODA


#ORAS
```



# pIOD Index 

```{r IOD_range}
#set IOD boundary points (from Cai et al 2021)
IOD_maxLon <- 100
IOD_minLon <- 40
IOD_maxLat <- 5
IOD_minLat <- -5

#IOD boundary as vector
IOD.lon.range <- c(IOD_minLon, IOD_maxLon)
IOD.lat.range <- c(IOD_minLat, IOD_maxLat) 
```

