---
title: "cluster_work"
author: "Ryan Peterson"
date: "2024-10-18"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}

```


```{r data_import}
setwd("~/CO_AUS/Aus_CO-main")

load( "ne_data.rda")
load( "se_data.rda")

load( "bounded_data.rda")
load( "data_matrix.rda")

load( "lag_list.rda")
```



```{r test_block}


neresp_test <- resp_matrix[, 1:32]
subset_test <- neresp_test[, 31:32]

centered_subset <- scale(subset_test, center = TRUE, scale = FALSE)

d <- dist(t(neresp_test))
#dist(t(neresp_test), diag = TRUE)
dist(t(centered_subset))
dist(t(subset_test))

d[which.min(d)]
```


```{r baseline_hclust}
#using hclust function without considering time-constraints

#using single-linked
NEbase_matrix <- scale(resp_matrix[, 1:32], center = TRUE, scale = FALSE)
NEtest_clust <- hclust(dist(t(NEbase_matrix)), method = "average")
plot(NEtest_clust)

SEbase_matrix <- scale(resp_matrix[,33:64], center = TRUE, scale = FALSE)
SEtest_clust <- hclust(dist(t(SEbase_matrix)), method = "average")
plot(SEtest_clust)

```


Test a naive single-linked agglomeration clustering

Then:
-create implementations for:
--single-linkage
--complete-linkage
--pair group with arithmetic mean (un-weighted and weighted)


```{r test_function}

#function to implement the single link agglomeration clustering algorithm
agglcluster_sl <- function() {
  
  
}

#internal function for subdiag (distance vector) update
vector_update <- function(dist_matrix, index_n, subdiag, min_ind) {
  #get updates from distance matrix
  min_loc <- index_n[1, ] 

  d_1 <- dist_matrix[min_loc[1], min_loc[2] - 1] #(49,51)
  d_2 <- dist_matrix[min_loc[1] + 1, min_loc[2]] #(50,52)

  d1_name <- colnames(dist_matrix)[ min_loc[2] - 1]
  d2_name <- rownames(dist_matrix)[min_loc[1] + 1]

  #update distance vector (originally the subdiagonal)
  sub_names <- names(subdiag)
  min_name <- sub_names[min_ind]
  
  t1 <- min(d_1, subdiag[min_ind-1])
  t1_name <- paste0("(",d1_name,",",min_name,")")
  t2 <- min(d_2, subdiag[min_ind+1])
  t2_name <- paste0("(",min_name,",",d2_name,")")

  temp_subdiag <- subdiag
  temp_subdiag[min_ind-1] <- t1
  sub_names[min_ind-1] <- t1_name

  temp_subdiag[min_ind+1] <- t2
  sub_names[min_ind+1] <- t2_name

  temp_subdiag <- temp_subdiag[-min_ind]
  sub_names <- sub_names[-min_ind]
  names(temp_subdiag) <- sub_names

  return(temp_subdiag)
}


```


```{r test_block}


#setup section:
base_matrix <- scale(resp_matrix[, 1:19], center = TRUE, scale = FALSE)
colnames(base_matrix) <- substring(colnames(base_matrix), 6)

#distance matrix
d <- dist(t(base_matrix))
temp_matrix <- as.matrix(d)
#TODO: update the name change as
dist_matrix <- as.matrix(d)

#loop 1 starts here
##sub-diagonal 
subdiag <- temp_matrix[col(temp_matrix) == row(temp_matrix) + 1]

#subdiag colnames as pair (,)
base_names <- colnames(base_matrix)
sub_names <- c()

n <- length(base_names)
for (i in 1:n-1) {
  first <- base_names[i]
  second <- base_names[i+1]
  sub_names <- c(sub_names, paste0("(",first,",",second,")"))
}

sub_names <- sub_names[-1]
names(subdiag) <- sub_names

subdiag

dend_df <- as.data.frame(matrix(NA, ncol = 2))
for (i in 1:3) {
  min_n <- min(subdiag)
  min_ind <- which.min(subdiag)
  min_name <- sub_names[min_ind]
  index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

  height_new <- min_n/2
  
  dend_df <- rbind(dend_df, c(height_new, min_name))

  subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
  print(subdiag)
}


#TODO: pick up after the next step since we are now connecting data that will have a lower height than an already connected section. 

#either address the above issue or change this some average linkage methods.
#perform some comparisons with the first distance matrix update using averages
#we also need elifs around the boundaries to avoid out of bounds issues.


```

```{r }
#minimum check (variation)

#min of subdiag, location, and name
min_n <- min(subdiag)
min_ind <- which.min(subdiag)
min_name <- sub_names[min_ind]
index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

#base_matrix[ ,index_n[1,]] #not needed (delete later)

#height
height_new <- min_n/2

#update
#TODO: update height/dendogram df (output)
subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
subdiag

min_n <- min(subdiag)
min_ind <- which.min(subdiag)
min_name <- sub_names[min_ind]
index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

height_new <- min_n/2

subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
subdiag
```


```{r test_updates}
#loop 2 (loop n+1)
min_loc <- index_n[1, ] 

min_loc[1]
min_loc[2]

d_1 <- dist_matrix[min_loc[1], min_loc[2] - 1] #(49,51)
d_2 <- dist_matrix[min_loc[1] + 1, min_loc[2]] #(50,52)

d1_name <- colnames(dist_matrix)[ min_loc[2] - 1]
d2_name <- rownames(dist_matrix)[min_loc[1] + 1]

subdiag[min_ind-1]
subdiag[min_ind+1]

min_name <- sub_names[min_ind]

t1 <- min(d_1, subdiag[min_ind-1])
t1_name <- paste0("(",d1_name,",",min_name,")")
t2 <- min(d_2, subdiag[min_ind+1])
t2_name <- paste0("(",min_name,",",d2_name,")")

#TODO; remove and rename temp_subdiag
temp_subdiag <- subdiag
temp_subdiag[min_ind-1] <- t1
sub_names[min_ind-1] <- t1_name

temp_subdiag[min_ind+1] <- t2
sub_names[min_ind+1] <- t2_name

temp_subdiag <- temp_subdiag[-min_ind]
sub_names <- sub_names[-min_ind]
names(temp_subdiag) <- sub_names

subdiag
temp_subdiag
```


```{r naive_single}
#using L2 distance

#disjoint of L(0) = 0
#set-up for week 35:52 and 1.
base_matrix <- scale(resp_matrix[, 1:19], center = TRUE, scale = FALSE)

#TODO: create df and/or create a new col names for the matrix
## change colnames to only number so we can track updates better

#test for this change:
upd_matrix <- base_matrix
colnames(upd_matrix) <- substring(colnames(base_matrix), 6)

d <- dist(t(base_matrix))

minval <- min(d)

mindex <- which(as.matrix(d) == minval, arr.ind = TRUE)

temp_matrix <- as.matrix(d)
#diag(temp_matrix, 1)

#TODO: plot this (add weeks in the half points (0.5, 1.5, ...))
subdiag <- temp_matrix[row(temp_matrix) == col(temp_matrix) + 1]
plot(subdiag, pch = 16) 

min_n <- min(subdiag) #min neighboring

index_n <- which(as.matrix(d) == min_n, arr.ind = TRUE)

base_matrix[ ,index_n[1,]]

#height 
height_1 <- dist(t(base_matrix[ ,index_n[1,]]))/2

which(col(temp_matrix) == index_n[1, ],  arr.ind = TRUE)



```

Compare below with a mean of $(a,b)$,
$$\min(D_1(a,c), D_1(b,c))$$

