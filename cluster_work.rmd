---
title: "cluster_work"
author: "Ryan Peterson"
date: "2024-10-18"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
suppressMessages(library(adespatial)) #for constr.hclust
```


```{r data_import}
setwd("~/CO_AUS/Aus_CO-main")

load( "ne_data.rda")
load( "se_data.rda")

load( "bounded_data.rda")
load( "data_matrix.rda")

load( "lag_list.rda")
```

```{r setup}
season_weeks <- c(35:52, 1:14)
```



```{r test_block}
neresp_test <- resp_matrix[, 1:32]
subset_test <- neresp_test[, 31:32]

centered_subset <- scale(subset_test, center = TRUE, scale = FALSE)

d <- dist(t(neresp_test))
#dist(t(neresp_test), diag = TRUE)
dist(t(centered_subset))
dist(t(subset_test))

d[which.min(d)]
```


```{r baseline_hclust}
#using hclust function without considering time-constraints

#using single-linked
NEbase_matrix <- scale(resp_matrix[, 1:32], center = TRUE, scale = FALSE)
NEtest_clust <- hclust(dist(t(NEbase_matrix)), method = "average")
plot(NEtest_clust)

SEbase_matrix <- scale(resp_matrix[,33:64], center = TRUE, scale = FALSE)
SEtest_clust <- hclust(dist(t(SEbase_matrix)), method = "average")
plot(SEtest_clust)

```


constr.hclust

```{r constr.hclust_test}
NEbase_matrix <- scale(resp_matrix[, 1:32], center = TRUE, scale = FALSE)
NEconst_clust <- constr.hclust(dist(t(NEbase_matrix)), chron = TRUE) #default with ward.d2 method
plot(NEconst_clust, k = 5) #either, k = 5 or 6
stats:::plot.hclust(NEconst_clust, hang = -1)

SEbase_matrix <- scale(resp_matrix[,33:64], center = TRUE, scale = FALSE)
SEconst_clust <- constr.hclust(dist(t(SEbase_matrix)), chron = TRUE) #default with ward.d2 method
plot(SEconst_clust, k = 5) #either, k = 4 or 5
stats:::plot.hclust(SEconst_clust, hang = -1)

#TODO: update the dendrograms to have ordered variables and colored groups.
```

```{r clustered_data}
#new matrices (eventually convert to list of df's or matrices)

#NEAus
NEAus_1 <- NEbase_matrix[ ,1:3]
NEAus_2 <- NEbase_matrix[ ,4:8]
NEAus_3 <- NEbase_matrix[ ,9:12]
NEAus_4 <- NEbase_matrix[ ,13:17]
NEAus_5 <- NEbase_matrix[ ,18:32]

#SEAus
SEAus_1 <- SEbase_matrix[ ,1:3]
SEAus_2 <- SEbase_matrix[ ,4:7]
SEAus_3 <- SEbase_matrix[ ,8:16]
SEAus_4 <- SEbase_matrix[ ,17:20]
SEAus_5 <- SEbase_matrix[ ,21:32]
```


```{r response_plots}
line_col <- rainbow(10)
y_range <- range(NEAus_2)
plot(1:5, NEAus_2[1,], type = "l", lwd = 2, xaxt = "n", ylim = y_range,
     ylab = "Anomaly (Total Column CO)", xlab = "Weeks")
axis(1, at=1:5, labels = season_weeks[4:8])
for (i in 2:7) {
  lines(1:5, NEAus_2[i,], lwd = 2, col = line_col[i])
}

```


Additional work, not currently needed.

Test a naive single-linked agglomeration clustering

Then:
-create implementations for:
--single-linkage
--complete-linkage
--pair group with arithmetic mean (un-weighted and weighted)


```{r test_function}

#function to implement the single link agglomeration clustering algorithm
agglcluster_sl <- function() {
  
  
}

#internal function for subdiag (distance vector) update
vector_update <- function(dist_matrix, index_n, subdiag, min_ind) {
  #get updates from distance matrix
  min_loc <- index_n[1, ] 

  #neighborhood checks (add in elif boundary checks)
  #TODO: assign min_ind and min_loc
  low <- min_ind-1
  upr <- min_ind+1
  
  
  d_1 <- dist_matrix[min_loc[1], min_loc[2] - 1] #(49,51)
  d_2 <- dist_matrix[min_loc[1] + 1, min_loc[2]] #(50,52)

  d1_name <- colnames(dist_matrix)[ min_loc[2] - 1]
  d2_name <- rownames(dist_matrix)[min_loc[1] + 1]

  #update distance vector (originally the subdiagonal)
  sub_names <- names(subdiag)
  min_name <- sub_names[min_ind]

  
  t1 <- min(d_1, subdiag[min_ind-1])
  t1_name <- paste0("(",d1_name,",",min_name,")")
  t2 <- min(d_2, subdiag[min_ind+1])
  t2_name <- paste0("(",min_name,",",d2_name,")")

  temp_subdiag <- subdiag
  temp_subdiag[min_ind-1] <- t1
  sub_names[min_ind-1] <- t1_name

  temp_subdiag[min_ind+1] <- t2
  sub_names[min_ind+1] <- t2_name

  temp_subdiag <- temp_subdiag[-min_ind]
  sub_names <- sub_names[-min_ind]
  names(temp_subdiag) <- sub_names

  return(temp_subdiag)
}


```


```{r test_block}


#setup section:
base_matrix <- scale(resp_matrix[, 1:19], center = TRUE, scale = FALSE)
colnames(base_matrix) <- substring(colnames(base_matrix), 6)

#distance matrix
d <- dist(t(base_matrix))
temp_matrix <- as.matrix(d)
#TODO: update the name change as
dist_matrix <- as.matrix(d)

#loop 1 starts here
##sub-diagonal 
subdiag <- temp_matrix[col(temp_matrix) == row(temp_matrix) + 1]

#subdiag colnames as pair (,)
base_names <- colnames(base_matrix)
sub_names <- c()

n <- length(base_names)
for (i in 1:n-1) {
  first <- base_names[i]
  second <- base_names[i+1]
  sub_names <- c(sub_names, paste0("(",first,",",second,")"))
}

sub_names <- sub_names[-1]
names(subdiag) <- sub_names

subdiag

dend_df <- as.data.frame(matrix(NA, ncol = 2))
for (i in 1:3) {
  min_n <- min(subdiag)
  min_ind <- which.min(subdiag)
  min_name <- sub_names[min_ind]
  index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

  height_new <- min_n/2
  
  dend_df <- rbind(dend_df, c(height_new, min_name))

  subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
  print(subdiag)
}


#TODO: pick up after the next step since we are now connecting data that will have a lower height than an already connected section. 

#either address the above issue or change this some average linkage methods.
#perform some comparisons with the first distance matrix update using averages
#we also need elifs around the boundaries to avoid out of bounds issues.


```


```{r minimizing_test}
min_n <- min(subdiag)
min_ind <- which.min(subdiag)
min_name <- sub_names[min_ind]
index_n <- which(temp_matrix == min_n, arr.ind = TRUE)
```


```{r function_tests}
#loop 2 (loop n+1)
min_loc <- index_n[1, ] 

min_loc[1]
min_loc[2]
names(subdiag)
subdiag[min_ind-1]
subdiag[min_ind+1]

#neighborhood checks (add in elif boundary checks)

#get lengths from matrix/vector
n_1 <- length(subdiag)
n_row <- nrow(dist_matrix)
n_col <- ncol(dist_matrix)


#TODO: assign min_ind and min_loc
low <- min_ind-1
upr <- min_ind+1


if (low < 1) {
  
}

d_1 <- dist_matrix[min_loc[1], min_loc[2] - 1] #(49,51)
d_2 <- dist_matrix[min_loc[1] + 1, min_loc[2]] #(50,52)

d1_name <- colnames(dist_matrix)[ min_loc[2] - 1]
d2_name <- rownames(dist_matrix)[min_loc[1] + 1]

#update distance vector (originally the subdiagonal)
sub_names <- names(subdiag)
min_name <- sub_names[min_ind]


t1 <- min(d_1, subdiag[min_ind-1])
t1_name <- paste0("(",d1_name,",",min_name,")")
t2 <- min(d_2, subdiag[min_ind+1])
t2_name <- paste0("(",min_name,",",d2_name,")")

temp_subdiag <- subdiag
temp_subdiag[min_ind-1] <- t1
sub_names[min_ind-1] <- t1_name

temp_subdiag[min_ind+1] <- t2
sub_names[min_ind+1] <- t2_name

temp_subdiag <- temp_subdiag[-min_ind]
sub_names <- sub_names[-min_ind]
names(temp_subdiag) <- sub_names
```


```{r }
#minimum check (variation)

#min of subdiag, location, and name
min_n <- min(subdiag)
min_ind <- which.min(subdiag)
min_name <- sub_names[min_ind]
index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

#base_matrix[ ,index_n[1,]] #not needed (delete later)

#height
height_new <- min_n/2

#update
#TODO: update height/dendogram df (output)
subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
subdiag

min_n <- min(subdiag)
min_ind <- which.min(subdiag)
min_name <- sub_names[min_ind]
index_n <- which(temp_matrix == min_n, arr.ind = TRUE)

height_new <- min_n/2

subdiag <- vector_update(dist_matrix, index_n, subdiag, min_ind)
subdiag
```


```{r naive_single}
#using L2 distance

#disjoint of L(0) = 0
#set-up for week 35:52 and 1.
base_matrix <- scale(resp_matrix[, 1:19], center = TRUE, scale = FALSE)

#TODO: create df and/or create a new col names for the matrix
## change colnames to only number so we can track updates better

#test for this change:
upd_matrix <- base_matrix
colnames(upd_matrix) <- substring(colnames(base_matrix), 6)

d <- dist(t(base_matrix))

minval <- min(d)

mindex <- which(as.matrix(d) == minval, arr.ind = TRUE)

temp_matrix <- as.matrix(d)
#diag(temp_matrix, 1)

#TODO: plot this (add weeks in the half points (0.5, 1.5, ...))
subdiag <- temp_matrix[row(temp_matrix) == col(temp_matrix) + 1]
plot(subdiag, pch = 16) 

min_n <- min(subdiag) #min neighboring

index_n <- which(as.matrix(d) == min_n, arr.ind = TRUE)

base_matrix[ ,index_n[1,]]

#height 
height_1 <- dist(t(base_matrix[ ,index_n[1,]]))/2

which(col(temp_matrix) == index_n[1, ],  arr.ind = TRUE)



```

Compare below with a mean of $(a,b)$,
$$\min(D_1(a,c), D_1(b,c))$$

