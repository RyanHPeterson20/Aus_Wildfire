---
title: "new_interaction"
author: "Ryan Peterson"
date: "2025-03-06"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library}
suppressMessages( library(hierNet)) #yes
suppressMessages( library(glinternet)) #no
suppressMessages( library(RAMP)) #maybe

suppressMessages( library( lubridate)) #you know why
suppressMessages( library( colorspace)) #for some color alternatives
suppressMessages( library( fields)) #for set.panel() and others 
suppressMessages( library(ggpubr)) #nice tables for dfs (uses ggplot)


suppressMessages( library( caret)) #for confusion matrix
```

```{r data_functions}
# Data Set-Up
setwd("~/CO_AUS/Aus_CO-main/Interactions")

load( "Data/ne_data.rda")
load( "Data/se_data.rda")
load( "Data/bounded_data.rda")
load( "Data/data_matrix.rda")
load( "Data/lag_list.rda")
load( "Data/data_quantile.rda")

#functions:
source("group_functions.R") #grouping/clustering
```

Goal of this is to include interaction terms into our methodology.

Beginning with:
1. hierNet
  a. Change response groups
  b. Try logistic regression for pos/neg (or threshold) 
2. glinternet (other hier methods)
3. Adding indicator terms into Will's quadratic fit (RAMP). 


Logistic Regression:
- If this works, update time series visualization for other thresholds
-- that is, if the logisitic regression requires some threshold other than 0 update the response TS viz.

#1 HierNet

Notes on HierNet:
- Use weak hierarchy to start
- Slowly build up with increasing "groups" of parameters.

Using different response groupings:
1. Base response clusters (e.g 4 groups)
2. Split response groups (2 groups; early/late)
(3. Full response for each region)

## Base Response Groups

NE Groups:
1. Weeks 35-46; Index 1-12
2. Weeks 47-51; Index 13-17
3. Weeks 52,1-3; Index 18-21
4. Weeks 4-14; Index 22-32

SE Groups:
1. Weeks 35-41; Index 1-7
2. Weeks 42-50; Index 8-16
3. Weeks 51,52,1,2; Index 17-20
4. Weeks 3-14; Index 21-32

```{r setup}
#set up 

#season years/weeks
season_weeks <- c(35:52, 1:14)
season_years <- unique(bounded_resp_df$year)

seasons <- c()
for (i in 1:(length(season_years)-1)) {
  temp_season <- paste0(season_years[i], "-", season_years[i+1])
  #print(temp_season)  
  seasons <- c(seasons, temp_season)
}
rm(i, temp_season)

#center response data
NEbase_matrix <- scale(resp_matrix[ ,1:32], center = TRUE, scale = FALSE)
SEbase_matrix <- scale(resp_matrix[ ,33:64], center = TRUE, scale = FALSE)

#group response matrices
#NEAus
NEAus_1 <- NEbase_matrix[ ,1:12] #early season
NEAus_2 <- NEbase_matrix[ ,13:17] #primary NE fire season
NEAus_3 <- NEbase_matrix[ ,18:21] #feedback from SE
NEAus_4 <- NEbase_matrix[ ,22:32] #late season

#SEAus
SEAus_1 <- SEbase_matrix[ ,1:7] #early season
SEAus_2 <- SEbase_matrix[ ,8:16] #feedback from NE
SEAus_3 <- SEbase_matrix[ ,17:20] #primary SE fire season
SEAus_4 <- SEbase_matrix[ ,21:32] #late season

NEAus_mat <- list(NEAus_1, NEAus_2, NEAus_3, NEAus_4)
SEAus_mat <- list(SEAus_1, SEAus_2, SEAus_3, SEAus_4)

rm(NEAus_1, NEAus_2, NEAus_3, NEAus_4, SEAus_1, SEAus_2, SEAus_3, SEAus_4)
```

```{r model_data}
#full model
NE_preds <- NElag_grouping(NE_laglist = NE_laglist_std, j = 1:18)
NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = 1:18)

SE_preds <- SElag_grouping(SE_laglist = SE_laglist_std, j = 1:18)
SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = 1:18)

#quantile 90 indicator
NE_preds_q90 <- NElag_grouping(NE_laglist = NE_laglist_q90, j = -c(19))
SE_preds_q90 <- SElag_grouping(SE_laglist = SE_laglist_q90, j = -c(19))

#quantile 75 indicator
NE_preds_q75 <- NElag_grouping(NE_laglist = NE_laglist_q75, j = 1:18)
SE_preds_q75 <- SElag_grouping(SE_laglist = SE_laglist_q75, j = 1:18)
```

```{r logit}
NEAus1 <- logit_NEresp[ ,1:12] #early season
NEAus2 <- logit_NEresp[ ,13:17] #primary NE fire season
NEAus3 <- logit_NEresp[ ,18:21] #feedback from SE
NEAus4 <- logit_NEresp[ ,22:32] #late season

#SEAus
SEAus1 <- logit_SEresp[ ,1:7] #early season
SEAus2 <- logit_SEresp[ ,8:16] #feedback from NE
SEAus3 <- logit_SEresp[ ,17:20] #primary SE fire season
SEAus4 <- logit_SEresp[ ,21:32] #late season

NEAusmat <- list(NEAus1, NEAus2, NEAus3, NEAus4)
SEAusmat <- list(SEAus1, SEAus2, SEAus3, SEAus4)

rm(NEAus1, NEAus2, NEAus3, NEAus4, SEAus1, SEAus2, SEAus3, SEAus4)

#setup data (resp/preds):
#resp
NElogitresp <- NEresp_grouping(NEAus_mat = NEAusmat, j = 1:18)
SElogitresp <- SEresp_grouping(SEAus_mat = SEAusmat, j = 1:18)
```


### Testing (Building-up Model) 

Develop hierNet with simpler combinations
- Nino + DMI

Currently works with 4 response group

```{r test_block}

NE1_path <- list()
NE1_cv <- list()
NE1_fit1 <- list() #lambdahat
NE1_fit2 <- list() #lambda1se

NE1_logitpath <- list()
NE1_logitcv <- list()
NE1_logitfit1 <- list() #lambdahat
NE1_logitfit2 <- list() #lambda1se

#TODO: change to for loop over all groups
n <- length(NE_resp) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(NE_resp[[i]])
  y_logit <- NElogitresp[[i]]

  #using only nino/dmi
  X_1 <- cbind(as.matrix(NE_preds[[i]][ ,1:260]),
             as.matrix(NE_preds_q75[[i]][ ,1:104])  )

  logit_path <- hierNet.logistic.path(X_1, y_logit, strong = FALSE, diagonal = TRUE)
  #path -> cv -> fit
  temp_path <- hierNet.path( X_1, y_1, strong = FALSE, diagonal = TRUE)
  temp_cv <- hierNet.cv(temp_path, X_1, y_1, nfolds = 5)

  temp_fit1 <- hierNet(X_1, y_1, lam = temp_cv$lamhat, strong = FALSE, diagonal = TRUE)
  temp_fit2 <- hierNet(X_1, y_1, lam = temp_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  NE1_path[[paste0("Group_", i)]] <- temp_path
  NE1_cv[[paste0("Group_", i)]] <- temp_cv
  NE1_fit1[[paste0("Group_", i)]] <- temp_fit1
  NE1_fit2[[paste0("Group_", i)]] <- temp_fit2
  

  logit_cv <- hierNet.cv(temp_path, X_1, y_logit, nfolds = 5)

  logit_fit1 <- hierNet.logistic(X_1, y_logit, lam = logit_cv$lamhat, strong = FALSE, diagonal = TRUE)
  logit_fit2 <- hierNet.logistic(X_1, y_logit, lam = logit_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  NE1_logitpath[[paste0("Group_", i)]] <- logit_path
  NE1_logitcv[[paste0("Group_", i)]] <- logit_cv
  NE1_logitfit1[[paste0("Group_", i)]] <- logit_fit1
  NE1_logitfit2[[paste0("Group_", i)]] <- logit_fit2
}


#SE--------------##
SE1_path <- list()
SE1_cv <- list()
SE1_fit1 <- list() #lambdahat
SE1_fit2 <- list() #lambda1se

SE1_logitpath <- list()
SE1_logitcv <- list()
SE1_logitfit1 <- list() #lambdahat
SE1_logitfit2 <- list() #lambda1se

n <- length(SE_resp) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(SE_resp[[i]])
  y_logit <- SElogitresp[[i]]
  
  #using only nino/dmi
  X_1 <- cbind(as.matrix(SE_preds[[i]][ ,1:260]),
                as.matrix(SE_preds_q75[[i]][ ,1:104]  ))

  #path -> cv -> fit
  temp_path <- hierNet.path( X_1, y_1, strong = FALSE, diagonal = TRUE)
  temp_cv <- hierNet.cv(temp_path, X_1, y_1, nfolds = 5)

  temp_fit1 <- hierNet(X_1, y_1, lam = temp_cv$lamhat, strong = FALSE, diagonal = TRUE)
  temp_fit2 <- hierNet(X_1, y_1, lam = temp_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  SE1_path[[paste0("Group_", i)]] <- temp_path
  SE1_cv[[paste0("Group_", i)]] <- temp_cv
  SE1_fit1[[paste0("Group_", i)]] <- temp_fit1
  SE1_fit2[[paste0("Group_", i)]] <- temp_fit2
  
  logit_path <- hierNet.logistic.path(X_1, y_logit, strong = FALSE, diagonal = TRUE)
  logit_cv <- hierNet.cv(temp_path, X_1, y_logit, nfolds = 5)

  logit_fit1 <- hierNet.logistic(X_1, y_logit, lam = logit_cv$lamhat, strong = FALSE, diagonal = TRUE)
  logit_fit2 <- hierNet.logistic(X_1, y_logit, lam = logit_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  SE1_logitpath[[paste0("Group_", i)]] <- logit_path
  SE1_logitcv[[paste0("Group_", i)]] <- logit_cv
  SE1_logitfit1[[paste0("Group_", i)]] <- logit_fit1
  SE1_logitfit2[[paste0("Group_", i)]] <- logit_fit2
}



setwd("~/CO_AUS/Aus_CO-main/Interactions")
save(SE1_fit1, SE1_fit2, SE1_cv, SE1_path, NE1_fit1, NE1_fit2, NE1_cv, NE1_path, file = "hiernet1_group.rda")
save(SE1_logitfit1, SE1_logitfit2, SE1_logitcv, SE1_logitcv, 
     NE1_logitfit1, NE1_logitfit2, NE1_logitcv, NE1_logitcv, file = "hiernet1_log.rda")
```


```{r cv_lambda}
set.panel(2,2)
plot(NE_cv[[1]])
plot(NE_cv[[2]])
plot(NE_cv[[3]])
plot(NE_cv[[4]])

set.panel(2,2)
plot(SE_cv[[1]])
plot(SE_cv[[2]])
plot(SE_cv[[3]])
plot(SE_cv[[4]])



set.panel(2,2)
plot(NE1_cv[[1]])
plot(NE1_cv[[2]])
plot(NE1_cv[[3]])
plot(NE1_cv[[4]])

set.panel(2,2)
plot(SE1_cv[[1]])
plot(SE1_cv[[2]])
plot(SE1_cv[[3]])
plot(SE1_cv[[4]])

```


```{r predict_2019/2020}
NE_new <- NElag_grouping(NE_laglist = NE_laglist_std, j = 19)
SE_new <- SElag_grouping(SE_laglist = SE_laglist_std, j = 19)

NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = 19)
SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = 19)

#quantile 75 indicator
NE_preds_q75 <- NElag_grouping(NE_laglist = NE_laglist_q75, j = 19)
SE_preds_q75 <- SElag_grouping(SE_laglist = SE_laglist_q75, j = 19)


#TODO: repeat for out sample preds (e.g. NE1_fit2 and SE1_fit2)
ne_yhat <- list()
ne1_yhat <- list()

neresp_new <- c()
n <- length(NE_resp)
for (i in 1:n) {
  y_1 <- as.numeric(NE_resp[[i]])
  neresp_new <- c(neresp_new, y_1)
  
  X_1 <- cbind(as.matrix(NE_new[[i]][ ,1:260]),
             as.matrix(NE_preds_q75[[i]][ ,1:104])  )
  
  yhat <- predict(NE_fit2[[i]], X_1)
  yhat1 <- predict(NE1_fit2[[i]], X_1)
  
  ne_yhat[[paste0("Group_", i)]] <- yhat
  ne1_yhat[[paste0("Group_", i)]] <- yhat1
}


se_yhat <- list()
se1_yhat <- list()

seresp_new <- c()
n <- length(SE_resp)
for (i in 1:n) {
  y_1 <- as.numeric(SE_resp[[i]])
  seresp_new <- c(seresp_new, y_1)
  
    
  X_1 <- cbind(as.matrix(SE_new[[i]][ ,1:260]),
             as.matrix(SE_preds_q75[[i]][ ,1:104])  )
  yhat <- predict(SE_fit2[[i]], X_1)
  yhat1 <- predict(SE1_fit2[[i]], X_1)
  
  se_yhat[[paste0("Group_", i)]] <- yhat
  se1_yhat[[paste0("Group_", i)]] <- yhat1
}


y_nehat <- c(ne_yhat[[1]], ne_yhat[[2]], ne_yhat[[3]], ne_yhat[[4]]) 
y_sehat <- c(se_yhat[[1]], se_yhat[[2]], se_yhat[[3]], se_yhat[[4]]) 

y1_nehat <- c(ne1_yhat[[1]], ne1_yhat[[2]], ne1_yhat[[3]], ne1_yhat[[4]]) 
y1_sehat <- c(se1_yhat[[1]], se1_yhat[[2]], se1_yhat[[3]], se1_yhat[[4]]) 

NE_g1 <- seq(12, 216, length.out = 18)
NE_g2 <- seq(5, 90, length.out = 18)
NE_g3 <- seq(4, 72, length.out = 18)
NE_g4 <- seq(11, 198, length.out = 18)


SE_g1 <- seq(7, 126, length.out = 18)
SE_g2 <- seq(9, 162, length.out = 18)
SE_g3 <- seq(4, 72, length.out = 18)
SE_g4 <- seq(12, 216, length.out = 18)
```


```{r }
#TODO: update with in/out sample predictions (needs key) and groups 
y_lim <- range(neresp_new, seresp_new)


setwd("~/CO_AUS/Aus_CO-main/Interactions")
  
png(filename = "the_season.png", width = 3200, height = 1500, res = 200)
set.panel(1,2)
#par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
plot(1:32, neresp_new,  type = "l", ylab = "Atmospheric CO", ylim = y_lim,
    xlab = "",  main = paste0("NE Aus: ", seasons[19]), axes = FALSE, 
    cex.main = 2, cex.lab = 1, cex.axis = 1)
box()
axis(2)
axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1)
lines(1:32, y_nehat, col = "magenta3", lwd = 1.5)
lines(1:32, y1_nehat, col = "darkmagenta", lty = 3, lwd = 2)
abline(h = 0, lty = 2)
abline(v = c(12.5, 17.5, 21.5), lty = 2, col = "red" )
legend("topright",
        legend = c("True", "In-Pred", "Out-Pred"),
        col = c("black", "magenta3", "darkmagenta"),
        lty = c(1, 1, 3),
        lwd = c(2, 2, 2))
text(5.5, -13, "Group 1", col = "red", cex = 1)
text(15, -13, "Group 2", col = "red", cex = 1)
text(19.5, -13, "Group 3", col = "red", cex = 1)
text(24.5, -13, "Group 4", col = "red", cex = 1)


#par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
plot(1:32, seresp_new,  type = "l", ylab = "Atmospheric CO", ylim = y_lim,
    xlab = "",  main = paste0("SE Aus: ", seasons[19]), axes = FALSE, 
    cex.main = 2, cex.lab = 1, cex.axis = 1)
box()
axis(2)
axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1)
lines(1:32, y_sehat, col = "magenta3", lwd = 1.5)
lines(1:32, y1_sehat, col = "darkmagenta", lty = 3, lwd = 2)
abline(h = 0, lty = 2)
abline(v = c(7.5, 16.5, 20.5), lty = 2, col = "red" )
legend("topright",
        legend = c("True", "In-Pred", "Out-Pred"),
        col = c("black", "magenta3", "darkmagenta"),
        lty = c(1, 1, 3),
        lwd = c(2, 2, 2))
text(3.5, -13, "Group 1", col = "red", cex = 1)
text(12, -13, "Group 2", col = "red", cex = 1)
text(18.5, -13, "Group 3", col = "red", cex = 1)
text(24.5, -13, "Group 4", col = "red", cex = 1)
dev.off()
```



### Predictions

```{r}
NE_season <- list()
SE_season <- list()

for (k in 1:19) {
    
  NE_new <- NElag_grouping(NE_laglist = NE_laglist_std, j = k)
  SE_new <- SElag_grouping(SE_laglist = SE_laglist_std, j = k)
  
  NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = k)
  SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = k)
  
  #quantile 75 indicator
  NE_preds_q75 <- NElag_grouping(NE_laglist = NE_laglist_q75, j = k)
  SE_preds_q75 <- SElag_grouping(SE_laglist = SE_laglist_q75, j = k)
  
  ne_yhat <- list()
  neresp_new <- c()
  n <- length(NE_resp)
  for (i in 1:n) {
    y_1 <- as.numeric(NE_resp[[i]])
    neresp_new <- c(neresp_new, y_1)
    
    X_1 <- cbind(as.matrix(NE_new[[i]][ ,1:260]),
               as.matrix(NE_preds_q75[[i]][ ,1:104])  )
    yhat <- predict(NE_fit1[[i]], X_1)
    
    ne_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  
  se_yhat <- list()
  seresp_new <- c()
  n <- length(SE_resp)
  for (i in 1:n) {
    y_1 <- as.numeric(SE_resp[[i]])
    seresp_new <- c(seresp_new, y_1)
    
      
    X_1 <- cbind(as.matrix(SE_new[[i]][ ,1:260]),
               as.matrix(SE_preds_q75[[i]][ ,1:104])  )
    
    yhat <- predict(SE_fit1[[i]], X_1)
    
    se_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  
  y_nehat <- c(ne_yhat[[1]], ne_yhat[[2]], ne_yhat[[3]], ne_yhat[[4]]) 
  y_sehat <- c(se_yhat[[1]], se_yhat[[2]], se_yhat[[3]], se_yhat[[4]]) 
  
  NE_season[[paste0("Season_", seasons[k])]] <- y_nehat
  SE_season[[paste0("Season_", seasons[k])]] <- y_sehat
  
  #visualizations
  x_vals <- 1:32
  
  setwd("~/CO_AUS/Aus_CO-main/Interactions")
  
  f_names <- paste0("Season_", seasons[k],".png" )
  
  png(filename = f_names, width = 3200, height = 1600, res = 200)
  set.panel(1,2)
  #par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
  plot(x_vals, neresp_new, type = "l", lwd = 2, ylim = range(neresp_new, y_nehat), 
          ylab = "Atmospheric CO",
          xlab = "",  main = paste0("NE Aus: ", seasons[k]), axes = FALSE, 
          cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
  box()
  axis(2)
  axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1.6)
  lines(1:32, y_nehat, col = "magenta3", lwd = 2)
  abline(h = 0, lty = 2) #TODO: correct this line
  
  #par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
  plot(x_vals, seresp_new, type = "l", lwd = 2, ylim = range(seresp_new, y_sehat), 
          ylab = "Atmospheric CO",
          xlab = "",  main = paste0("SE Aus: ", seasons[k]), axes = FALSE, 
          cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
  box()
  axis(2)
  axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1.6)
  lines(1:32, y_sehat, col = "magenta3", lwd = 2)
  abline(h = 0, lty = 2) #TODO: correct this line
  
  
  dev.off()
}

```

### Prediction Visualizations

```{r predviz_test}
#using will's code to viz preds and data
#create plot for each region

new_resp <- bounded_resp_df[which(bounded_resp_df$week %in% season_weeks, arr.ind = TRUE), ]
new_resp <- new_resp[-c(1:14), ]

#response data:
temp_resp <- scale(new_resp$NE_Aus_anomaly_co, center = TRUE, scale = FALSE) 
temp_time <- as.Date(new_resp$time)

#TODO: remove everything outside of wildfire season
out_season <- 15:34
 
xlim_val <- ymd(c("20010103", "20200401"))
plot(x = temp_time, y = temp_resp, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1)

#NEbase_matrix

NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = 1:19)
SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = 1:19)

#prediction data:
NE_hat <- c()
for (i in 1:19) {
  NE_hat <- c(NE_hat, NE_season[[i]])
}


#base test

#TODO: touch up this visualization to include the necessary labels
xlim_val <- ymd(c("20010103", "20200401"))
plot(x = temp_time, y = temp_resp, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1, ylab = "CO Anomaly", xlab = "",
     main = "NE Aus")
points(x = temp_time, y = NE_hat, pch = 17, 
     col = "magenta3", cex = 0.85)

#'sparse' test
NEAUS_df <- data.frame(time = temp_time, true = temp_resp, pred = NE_hat)
NEAUS_tempdf <- NEAUS_df[-seq(3, nrow(NEAUS_df), by = 4), ]

plot(x = NEAUS_tempdf$time, y = NEAUS_tempdf$true, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1, ylab = "CO Anomaly", xlab = "",
     main = "NE Aus")
points(x = NEAUS_tempdf$time, y = NEAUS_tempdf$pred, pch = 17, 
     col = "magenta3", cex = 0.85)

```

```{r pred_viz}
#extract seasons
new_resp <- bounded_resp_df[which(bounded_resp_df$week %in% season_weeks, arr.ind = TRUE), ]
new_resp <- new_resp[-c(1:14), ]

#setup vertical year lines
unique_yr <- unique(year(new_resp$time))
year_lines <- c(unique_yr[1:length(unique_yr)])
year_lines <- paste0(year_lines, "0101")
year_lines <- as_date(year_lines)

#year_text <- year_lines
#year_text <- as_date(year_text) + months(6)
year_text <- year_lines + months(6)

xlim_val <- ymd(c("20010829", "20200401"))

temp_NE <- scale(new_resp$NE_Aus_anomaly_co, center = TRUE, scale = FALSE) 
temp_SE <- scale(new_resp$SE_Aus_anomaly_co, center = TRUE, scale = FALSE) 
temp_time <- as.Date(new_resp$time)

#prediction data:
NE_hat <- c()
SE_hat <- c()
for (i in 1:19) {
  NE_hat <- c(NE_hat, NE_season[[i]])
  SE_hat <- c(SE_hat, SE_season[[i]])
}

#region DFs
NEAUS_df <- data.frame(time = temp_time, true = temp_NE, pred = NE_hat)
SEAUS_df <- data.frame(time = temp_time, true = temp_SE, pred = SE_hat)

#full plots
  
setwd("~/CO_AUS/Aus_CO-main/Interactions")
  
png(filename = "NEAUS_preds.png", width = 2400, height = 1100, res = 200)
par(mar = c(3,5,4,1))
plot(x = NEAUS_df$time, y = NEAUS_df$true, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1.33,
     xaxt = "n",  xlab = "",
     ylab = "CO Anomaly", 
     main = "NE Aus : Predictions")
points(x = NEAUS_df$time, y = NEAUS_df$pred, pch = 17, 
     col = "magenta3", cex = 1)
abline(v = year_lines[-1], lty = 2)
abline(h = 0, lty = 2)
legend("bottomleft", inset = c(0.00, 0),
       legend = c("True", "Pred"),
       col = c("black", "magenta3"),
       pch = c(18,17),
       pt.cex = c(1.33,1))
axis(side = 1, at = year_text, labels = unique_yr, tick = FALSE, cex.axis = 1)
dev.off()

png(filename = "SEAUS_preds.png", width = 2400, height = 1100, res = 200)
par(mar = c(3,5,4,1))
plot(x = SEAUS_df$time, y = SEAUS_df$true, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1.33,
     xaxt = "n",  xlab = "",
     ylab = "CO Anomaly", 
     main = "SE Aus : Predictions")
points(x = SEAUS_df$time, y = SEAUS_df$pred, pch = 17, 
     col = "magenta3", cex = 1)
abline(v = year_lines[-1], lty = 2)
abline(h = 0, lty = 2)
legend("bottomleft", inset = c(0.00, 0),
       legend = c("True", "Pred"),
       col = c("black", "magenta3"),
       pch = c(18,17),
       pt.cex = c(1.33,1))
axis(side = 1, at = year_text, labels = unique_yr, tick = FALSE, cex.axis = 1)
dev.off()

```


### Residuals

```{r resids}
#get residuals (y - yhat)
NE_resids <- matrix(NA, ncol = 32)
SE_resids <- matrix(NA, ncol = 32)

for (k in 1:19) {
  temp_NE <- NEbase_matrix[k, ] - NE_season[[k]]
  temp_SE <- SEbase_matrix[k, ] - SE_season[[k]]
  
  NE_resids <- rbind(NE_resids, temp_NE)
  SE_resids <- rbind(SE_resids, temp_SE)
}

NE_resids <- NE_resids[-1, ]
SE_resids <- SE_resids[-1, ]

```


```{r}
#TODO: update using the same scale as fused lasso

boxplot(NE_resids, pch = 20, ylim = c(-20,20), main ="NE Aus")
abline(h = 0, lty = 2)

boxplot(SE_resids, pch = 20, ylim = c(-20,20), main ="SE Aus")
abline(h = 0, lty = 2)
```


```{r resid_output}

setwd("~/CO_AUS/Aus_CO-main/Interactions")

png("NEresid.png", width = 2250, height = 1250, res = 200)
par(mar = c(8, 4, 4, 2) + 0.2)
boxplot(NE_resids, ylim = c(-20,20), ylab = "Residuals", xlab = "",
        main = "NE Aus : Model Residuals",axes = FALSE, pch = 20, 
         cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
box()
axis(2)
axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
     las = 3, cex.axis = 1.6)
abline(h = 0, lty = 2)
abline(v = c(12.5, 17.5, 21.5), lty =2, col = "red")
text(7, -15, "Group 1", col = "red", cex =1)
text(15, -15, "Group 2", col = "red", cex = 1)
text(19.5, -15, "Group 3", col = "red", cex = 1)
text(27, -15, "Group 4", col = "red", cex = 1)
dev.off()

png("SEresid.png", width = 2250, height = 1250, res = 200)
par(mar = c(8, 4, 4, 2) + 0.2)
boxplot(SE_resids, ylim = c(-20,20), ylab = "Residuals", xlab = "",
        main = "SE Aus : Model Residuals",axes = FALSE, pch = 20, 
         cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
box()
axis(2)
axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
     las = 3, cex.axis = 1.6)
abline(h = 0, lty = 2)
abline(v = c(7.5, 16.5, 20.5), lty =2, col = "red")
text(4, -15, "Group 1", col = "red", cex =1)
text(12, -15, "Group 2", col = "red", cex = 1)
text(18.5, -15, "Group 3", col = "red", cex = 1)
text(26, -15, "Group 4", col = "red", cex = 1)
dev.off()

```





### Variable Importance

```{r var_imp}
#TODO: change this for each group and region
#create for loop to work through each group (and region)
k <- 1:19 #season
NE_new <- NElag_grouping(NE_laglist = NE_laglist_std, j = k)
SE_new <- SElag_grouping(SE_laglist = SE_laglist_std, j = k)

NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = k)
SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = k)

#quantile 75 indicator
NE_preds_q75 <- NElag_grouping(NE_laglist = NE_laglist_q75, j = k)
SE_preds_q75 <- SElag_grouping(SE_laglist = SE_laglist_q75, j = k)

i <- 1 #group
y_1 <- as.numeric(NE_resp[[i]])
  
X_1 <- cbind(as.matrix(NE_new[[i]][ ,1:260]),
           as.matrix(NE_preds_q75[[i]][ ,1:104])  )


test_fit <- NE_fit1[[i]]

#NOTE: this takes forever!!
var_imp <- hierNet.varimp(test_fit, X_1, y_1)

plot(var_imp[,1], var_imp[,2], pch = 20)

setwd("~/CO_AUS/Aus_CO-main/Interactions")
save(var_imp, file = "temp_varimp.rda")
```


### Logistic - Predictions

```{r}

```


Check on confusion matrix followed by overall accuracy, sensitivity, and specificity


```{r conf_mat}

```



### Coefficients

```{r coefs}

#TODO: get a good description of interactions
test_coef <- test_fit$bp-test_fit$bn

plot(1:52, test_coef[1:52], pch = 16, col = "red3")
points(1:52, test_coef[53:104], pch = 16, col = "blue3")
abline(h = 0)

set.panel(1,2)
image.plot(test_fit$th[ ,1:52], col = diverge_hsv(256))
image.plot(test_fit$th, col = diverge_hsv(256))
abline(h=0.5, lty = 2)

th_nino <- test_fit$th[1:52, 1:52]
th_dmi <- test_fit$th[53:104, 53:104]

nino_int <- which(th_nino !=0, arr.ind = TRUE)
dmi_int <- which(th_dmi !=0, arr.ind = TRUE)
#TODO: add coefs into the above matrices (change to df)

image.plot(test_fit$th[1:52, 1:52], col = diverge_hsv(256))
image.plot(test_fit$th[53:104, 53:104], col = diverge_hsv(256))

#temp <- (th+t(th))/2
#test_interact <- which(temp !=0, arr.ind = TRUE)


test_int[1:42,]

```

```{r coef_Explore}
#TODO: functionalize this so we can repeat it for all groups/regions

#get NE_fit and SE_fit coefs, also visualize 
#Begin with SE Group 3 (and cv.lambda1se since there are only 32 terms)
temp_fit <- SE_fit2[[3]]

#TODO: create a method to relate index to coefficient names
coef_namesNE <- c(colnames(NE_preds[[1]]), paste0( "IND_", colnames(NE_preds_q75[[1]][ ,1:104]) ) )
coef_namesSE <- c(colnames(SE_preds[[1]]), paste0( "IND_", colnames(SE_preds_q75[[1]][ ,1:104]) ) )

main_eff <- temp_fit$bp - temp_fit$bn
length(which(main_eff != 0, arr.ind = TRUE))
main_names <- coef_namesSE[which(main_eff != 0, arr.ind = TRUE)]
coef_main <- main_eff[which(main_eff != 0, arr.ind = TRUE)]

main_loc <- which(main_eff != 0, arr.ind = TRUE)

main_df <- data.frame(main_names, round(coef_main, 5))

interact_eff <- temp_fit$th
length(which(interact_eff != 0, arr.ind = TRUE))
which_mat <- which(interact_eff != 0, arr.ind = TRUE)


interact_names <- matrix(coef_names[which_mat], nrow = nrow(which_mat), ncol = ncol(which_mat))
#interact_names
coef_int <- interact_eff[which(interact_eff != 0, arr.ind = TRUE)]

interact_df <- data.frame(paste0(interact_names[,2]," : ", interact_names[,1]), round(coef_int, 5) )

rownames(main_df) <- NULL
rownames(interact_df) <- NULL

colnames(main_df) <- c("Main Effect", "Coef")
colnames(interact_df) <- c("Interaction", "Coef")

main_df
interact_df
```


```{r coef_compare}
temp_fit <- SE1_fit2[[3]]

main_eff <- temp_fit$bp - temp_fit$bn
length(which(main_eff != 0, arr.ind = TRUE))
main_names <- coef_namesSE[which(main_eff != 0, arr.ind = TRUE)]
coef1_main <- main_eff[which(main_eff != 0, arr.ind = TRUE)]

#TODO: get location from main_eff as x and value as y for a plot
main1_loc <- which(main_eff != 0, arr.ind = TRUE)

main1_df <- data.frame(main_names, round(coef1_main, 5))

interact_eff <- temp_fit$th
length(which(interact_eff != 0, arr.ind = TRUE))
which_mat <- which(interact_eff != 0, arr.ind = TRUE)


interact_names <- matrix(coef_names[which_mat], nrow = nrow(which_mat), ncol = ncol(which_mat))
#interact_names
coef_int <- interact_eff[which(interact_eff != 0, arr.ind = TRUE)]

interact1_df <- data.frame(paste0(interact_names[,2]," : ", interact_names[,1]), round(coef_int, 5) )

rownames(main1_df) <- NULL
rownames(interact1_df) <- NULL

colnames(main1_df) <- c("Main Effect", "Coef")
colnames(interact1_df) <- c("Interaction", "Coef")


main1_df
interact1_df
```


### Coef Plots/Tables

```{r create_xaxis}
lag_at <- c(1, 52, 53, 104, 105, 156, 157, 208, 209, 260)

#TODO add the 1 back in but shift slightly to the right
text_atnew <- c(1, 51.8, 103.8, 155.8, 207.8, 260)
label_new <- c(1, rep(52, 5))

text_one <- c(53, 105, 157, 209) 
label_one <- rep(1, 4)
tick_angles <- rep(25, 4)

radians <- tick_angles * pi / 180
dist_factor <- 0.77
```


```{r coef_plots}
#TODO: add labels and makes this a better plot, also split into two for base and indicators
#fix the labels by slightly shifting the values 52, 1 away from each other 
#TODO remove the angle

plot(main_loc, coef_main, pch = 16, xlim = c(0,260), main = "SE Aus : Group 3",
     ylab = "Coefficients", xlab = "", xaxt = "n")
points(main1_loc, coef1_main, pch = 16, col = "magenta3")
abline(h=0, lty =2)
abline(v =c(0,52.5, 104.5, 156.5, 208.5, 260), lty = 2, col = "blue3")
axis(1, at = lag_at, labels = FALSE)
text(text_atnew, par("usr")[3]-0.15, labels = label_new, xpd = TRUE, adj = 1, cex = 0.75)
# Add manually rotated tick labels
for (i in seq_along(text_one)) {
  text(
      x = text_one[i] + dist_factor * cos(radians[i]),  
      y = par("usr")[3] - 0.5 + dist_factor * sin(radians[i]),  
      labels = label_one[i], 
      srt = tick_angles[i], xpd = TRUE, adj = 0, cex = 0.75)
}
text(x= c(26, 78, 130, 182, 234),
     y =par("usr")[3]-0.25,
     labels = c("Nino", "DMI", "TSA", "AAO", "OLR"), 
     xpd = TRUE, adj = 1)
text(x = -4.5, par("usr")[3]-0.155, labels = c("Lag"), xpd = TRUE, adj = 1, cex = 0.75)

#TODO: add legends and repeat some of this for the indicator functions
```


```{r }
#indicator expression
ind_exp <- c( expression(bold("1")["{Nino > 0.581}"]), 
              expression(bold("1")["{DMI > 0.551}"]))

#TODO: make this plot better, like the one from above
plot(main_loc, coef_main, pch = 16, xlim = c(261,365),
     ylab = "Coefficients", xlab = "", xaxt = "n")
points(main1_loc, coef1_main, pch = 16, col = "magenta3")
abline(h=0, lty =2)
abline(v = c(260, 310.5, 364), lty = 2, col = "blue3")
text(x = c(286, 338),
     y =par("usr")[3]-0.25,
     labels = ind_exp, 
     xpd = TRUE, adj = 1)

#TODO: add interaction plot and use color for intensity with labels
```

```{r test_blcok}

# Convert data frames to table plots
table_theme <- ttheme(
  tbody.style = tbody_style(
   hjust = 0, x = 0.1))

#in sample
table1 <- ggtexttable(main_df, rows = NULL, theme =table_theme)
table2 <- ggtexttable(interact_df, rows = NULL, theme = table_theme)

table_plot <- ggarrange(table1, table2, ncol = 2)

#out sample
table1out <- ggtexttable(main1_df, rows = NULL, theme =table_theme)
table2out <- ggtexttable(interact1_df, rows = NULL, theme = table_theme)

table_plotout <- ggarrange(table1out, table2out, ncol = 2)

setwd("~/CO_AUS/Aus_CO-main/Interactions")
ggsave("SE_in2.png", plot = table_plot, width = 7, height = 5, dpi = 300)
ggsave("SE_out2.png", plot = table_plotout, width = 7, height = 5, dpi = 300)
```


## Set-up Other Groups

Re-Run tonight for full data set (and logistic).

Repeat above with only two groups:
NE Groups:
1. Weeks 35-46; Index 1-12
2. Weeks 47-52, 1-14; Index 13-32

SE Groups:
1. Weeks 35-50; Index 1-16
2. Weeks 51, 52, 1-14; Index 17-32

```{r new_groups}
#updated lists 
##predictors
NE_group1 <- NE_preds[[1]]
NE_group2 <- rbind(NE_preds[[2]], NE_preds[[3]], NE_preds[[4]])
NE_preds1 <- list(NE_group1, NE_group2)

SE_group1 <- rbind(SE_preds[[1]], SE_preds[[2]])
SE_group2 <- rbind(SE_preds[[3]], SE_preds[[4]])
SE_preds1 <- list(SE_group1, SE_group2)

##response
NEresp1 <- NE_resp[[1]]
NEresp2 <- c(NE_resp[[2]], NE_resp[[3]], NE_resp[[4]])
NE_resp1 <- list(NEresp1, NEresp2)

SEresp1 <- c(SE_resp[[1]], SE_resp[[2]])
SEresp2 <- c(SE_resp[[3]], SE_resp[[4]])
SE_resp1 <- list(SEresp1, SEresp2)

##indicator preds (q75)

NEq75_pred1 <- NE_preds_q75[[1]]
NEq75_pred2 <- rbind(NE_preds_q75[[2]], NE_preds_q75[[3]], NE_preds_q75[[4]])
NE_preds1_q75 <- list(NEq75_pred1, NEq75_pred2)

SEq75_pred1 <- rbind(SE_preds_q75[[1]], SE_preds_q75[[2]])
SEq75_pred2 <- rbind(SE_preds_q75[[3]], SE_preds_q75[[4]])
SE_preds1_q75 <- list(SEq75_pred1, SEq75_pred2)

```


```{r function}
#create functions
NEpreds <- function(NE_preds){
  NE_group1 <- NE_preds[[1]]
  NE_group2 <- rbind(NE_preds[[2]], NE_preds[[3]], NE_preds[[4]])
  return(list(NE_group1, NE_group2))
}

SEpreds <- function(SE_preds){
  SE_group1 <- rbind(SE_preds[[1]], SE_preds[[2]])
  SE_group2 <- rbind(SE_preds[[3]], SE_preds[[4]])
  return(list(SE_group1, SE_group2))
}

NEresp <- function(NE_resp){
  NEresp1 <- NE_resp[[1]]
  NEresp2 <- c(NE_resp[[2]], NE_resp[[3]], NE_resp[[4]])
  return(list(NEresp1, NEresp2))
}

SEresp <- function(SE_resp){
  SEresp1 <- c(SE_resp[[1]], SE_resp[[2]])
  SEresp2 <- c(SE_resp[[3]], SE_resp[[4]])
  return(list(SEresp1, SEresp2))
}


```


### Model Fit

(2 groups per region)

```{r test_block}
NE_path1 <- list()
NE_cv1 <- list()
NE_fit1 <- list()

#TODO: change to for loop over all groups
n <- length(NE_resp1) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(NE_resp1[[i]])

  #using only nino/dmi
  X_1 <- cbind(as.matrix(NE_preds1[[i]][ ,1:260]),
             as.matrix(NE_preds1_q75[[i]][ ,1:104])  )

  #path -> cv -> fit
  temp_path <- hierNet.path( X_1, y_1, strong = FALSE, diagonal = TRUE)
  
  set.seed(155)
  temp_cv <- hierNet.cv(temp_path, X_1, y_1, nfolds = 5)

  temp_fit <- hierNet(X_1, y_1, lam = temp_cv$lamhat, strong = FALSE, diagonal = TRUE)
  
  NE_path1[[paste0("Group_", i)]] <- temp_path
  NE_cv1[[paste0("Group_", i)]] <- temp_cv
  NE_fit1[[paste0("Group_", i)]] <- temp_fit
}

plot(NE_cv1[[1]])
plot(NE_cv1[[2]])


#SE--------------##
SE_path1 <- list()
SE_cv1 <- list()
SE_fit1 <- list()

n <- length(SE_resp1) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(SE_resp1[[i]])

  #using only nino/dmi
  X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
                as.matrix(SE_preds1_q75[[i]][ ,1:104]  ))

  #path -> cv -> fit
  temp_path <- hierNet.path( X_1, y_1, strong = FALSE, diagonal = TRUE)
  
  set.seed(155)
  temp_cv <- hierNet.cv(temp_path, X_1, y_1, nfolds = 5)

  temp_fit <- hierNet(X_1, y_1, lam = temp_cv$lamhat, strong = FALSE, diagonal = TRUE)
  
  SE_path1[[paste0("Group_", i)]] <- temp_path
  SE_cv1[[paste0("Group_", i)]] <- temp_cv
  SE_fit1[[paste0("Group_", i)]] <- temp_fit
}

plot(SE_cv1[[1]])
plot(SE_cv1[[2]])

setwd("~/CO_AUS/Aus_CO-main/Interactions")
save(SE_fit1, SE_cv1, SE_path1, NE_fit1, NE_cv1, NE_path1, file = "hiernet_group1.rda")

```


```{r}
#play with lambda in fit
NE_fit2 <- list()

#TODO: change to for loop over all groups
n <- length(NE_resp1) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(NE_resp1[[i]])

  #using only nino/dmi
  X_1 <- cbind(as.matrix(NE_preds1[[i]][ ,1:260]),
             as.matrix(NE_preds1_q75[[i]][ ,1:104])  )

  temp_cv <- NE_cv1[[i]]
  temp_fit <- hierNet(X_1, y_1, lam = temp_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  NE_fit2[[paste0("Group_", i)]] <- temp_fit
}


SE_fit2 <- list()

#TODO: change to for loop over all groups
n <- length(SE_resp1) #setup for loop over list of groups
for (i in 1:n) {
  y_1 <- as.numeric(SE_resp1[[i]])

  #using only nino/dmi
  X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

  temp_cv <- SE_cv1[[i]]
  temp_fit <- hierNet(X_1, y_1, lam = temp_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
  
  SE_fit2[[paste0("Group_", i)]] <- temp_fit
}
```


```{r 2019-2020pred}

NE_new <- NElag_grouping(NE_laglist = NE_laglist_std, j = 19)
SE_new <- SElag_grouping(SE_laglist = SE_laglist_std, j = 19)

NE_resp <- NEresp_grouping(NEAus_mat = NEAus_mat, j = 19)
SE_resp <- SEresp_grouping(SEAus_mat = SEAus_mat, j = 19)

#quantile 75 indicator
NE_preds_q75 <- NElag_grouping(NE_laglist = NE_laglist_q75, j = 19)
SE_preds_q75 <- SElag_grouping(SE_laglist = SE_laglist_q75, j = 19)


NE_group1 <- NE_new[[1]]
NE_group2 <- rbind(NE_new[[2]], NE_new[[3]], NE_new[[4]])
NE_preds1 <- list(NE_group1, NE_group2)

SE_group1 <- rbind(SE_new[[1]], SE_new[[2]])
SE_group2 <- rbind(SE_new[[3]], SE_new[[4]])
SE_preds1 <- list(SE_group1, SE_group2)

##response
NEresp1 <- NE_resp[[1]]
NEresp2 <- c(NE_resp[[2]], NE_resp[[3]], NE_resp[[4]])
NE_resp1 <- list(NEresp1, NEresp2)

SEresp1 <- c(SE_resp[[1]], SE_resp[[2]])
SEresp2 <- c(SE_resp[[3]], SE_resp[[4]])
SE_resp1 <- list(SEresp1, SEresp2)

##indicator preds (q75)

NEq75_pred1 <- NE_preds_q75[[1]]
NEq75_pred2 <- rbind(NE_preds_q75[[2]], NE_preds_q75[[3]], NE_preds_q75[[4]])
NE_preds1_q75 <- list(NEq75_pred1, NEq75_pred2)

SEq75_pred1 <- rbind(SE_preds_q75[[1]], SE_preds_q75[[2]])
SEq75_pred2 <- rbind(SE_preds_q75[[3]], SE_preds_q75[[4]])
SE_preds1_q75 <- list(SEq75_pred1, SEq75_pred2)


ne_yhat <- list()
neresp_new <- c()
n <- length(NE_resp1)
for (i in 1:n) {
  y_1 <- as.numeric(NE_resp1[[i]])
  neresp_new <- c(neresp_new, y_1)
  
  X_1 <- cbind(as.matrix(NE_preds1[[i]][ ,1:260]),
             as.matrix(NE_preds1_q75[[i]][ ,1:104])  )
  yhat <- predict(NE_fit2[[i]], X_1)
  
  ne_yhat[[paste0("Group_", i)]] <- yhat
}


se_yhat <- list()
seresp_new <- c()
n <- length(SE_resp1)
for (i in 1:n) {
  y_1 <- as.numeric(SE_resp1[[i]])
  seresp_new <- c(seresp_new, y_1)
  
    
  X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )
  yhat <- predict(SE_fit2[[i]], X_1)
  
  se_yhat[[paste0("Group_", i)]] <- yhat
}

y_nehat <- c(ne_yhat[[1]], ne_yhat[[2]]) 
y_sehat <- c(se_yhat[[1]], se_yhat[[2]]) 

plot(1:32, neresp_new,  type = "l")
lines(1:32, y_nehat, col = "magenta3")
abline(h = 0, lty = 2)

plot(1:32, seresp_new,  type = "l")
lines(1:32, y_sehat, col = "magenta3")
abline(h = 0, lty = 2)
```



### Predictions

```{r}
NE_season <- list()
SE_season <- list()

for (k in 1:18) {
    
  NE_new <- NEpreds(NElag_grouping(NE_laglist = NE_laglist_std, j = k))
  SE_new <- SEpreds(SElag_grouping(SE_laglist = SE_laglist_std, j = k))
  
  NE_resp <- NEresp(NEresp_grouping(NEAus_mat = NEAus_mat, j = k))
  SE_resp <- SEresp(SEresp_grouping(SEAus_mat = SEAus_mat, j = k))
  
  #quantile 75 indicator
  NE_preds_q75 <- NEpreds(NElag_grouping(NE_laglist = NE_laglist_q75, j = k))
  SE_preds_q75 <- SEpreds(SElag_grouping(SE_laglist = SE_laglist_q75, j = k))
  
  ne_yhat <- list()
  neresp_new <- c()
  n <- length(NE_resp)
  for (i in 1:n) {
    y_1 <- as.numeric(NE_resp[[i]])
    neresp_new <- c(neresp_new, y_1)
    
    X_1 <- cbind(as.matrix(NE_new[[i]][ ,1:260]),
               as.matrix(NE_preds_q75[[i]][ ,1:104])  )
    yhat <- predict(NE_fit1[[i]], X_1)
    
    ne_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  
  se_yhat <- list()
  seresp_new <- c()
  n <- length(SE_resp)
  for (i in 1:n) {
    y_1 <- as.numeric(SE_resp[[i]])
    seresp_new <- c(seresp_new, y_1)
    
      
    X_1 <- cbind(as.matrix(SE_new[[i]][ ,1:260]),
               as.matrix(SE_preds_q75[[i]][ ,1:104])  )
    yhat <- predict(SE_fit1[[i]], X_1)
    
    se_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  
  y_nehat <- c(ne_yhat[[1]], ne_yhat[[2]]) 
  y_sehat <- c(se_yhat[[1]], se_yhat[[2]]) 
  
  NE_season[[paste0("Season_", seasons[k])]] <- y_nehat
  SE_season[[paste0("Season_", seasons[k])]] <- y_sehat
  
  #visualizations
  x_vals <- 1:32
  
  setwd("~/CO_AUS/Aus_CO-main/Interactions")
  
  f_names <- paste0("Season_", seasons[k],"_1.png" )
  
  png(filename = f_names, width = 3200, height = 1600, res = 200)
  set.panel(1,2)
  #par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
  plot(x_vals, neresp_new, type = "l", lwd = 2, ylim = range(neresp_new, y_nehat), 
          ylab = "Atmospheric CO",
          xlab = "",  main = paste0("NE Aus: ", seasons[k]), axes = FALSE, 
          cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
  box()
  axis(2)
  axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1.6)
  lines(1:32, y_nehat, col = "magenta3", lwd = 2)
  abline(h = 0, lty = 2) #TODO: correct this line
  
  #par(mar = c(7, 4, 4, 11) + 0.3, xpd = TRUE) 
  plot(x_vals, seresp_new, type = "l", lwd = 2, ylim = range(seresp_new, y_sehat), 
          ylab = "Atmospheric CO",
          xlab = "",  main = paste0("SE Aus: ", seasons[k]), axes = FALSE, 
          cex.main = 2.25, cex.lab = 1.5, cex.axis = 1.5)
  box()
  axis(2)
  axis(1, at = 1:32, labels = c(paste0("Week ", season_weeks)),
       las = 3, cex.axis = 1.6)
  lines(1:32, y_sehat, col = "magenta3", lwd = 2)
  abline(h = 0, lty = 2) #TODO: correct this line
  
  dev.off()
}

```

### Residuals

```{r residuals}
#get residuals (y - yhat)
NE_resids <- matrix(NA, ncol = 32)
SE_resids <- matrix(NA, ncol = 32)

for (k in 1:18) {
  temp_NE <- NEbase_matrix[k, ] - NE_season[[k]]
  temp_SE <- SEbase_matrix[k, ] - SE_season[[k]]
  
  NE_resids <- rbind(NE_resids, temp_NE)
  SE_resids <- rbind(SE_resids, temp_SE)
}

NE_resids <- NE_resids[-1, ]
SE_resids <- SE_resids[-1, ]

#TODO: update using the same scale as fused lasso

boxplot(NE_resids, pch = 20, ylim = c(-20,20))
abline(h = 0, lty = 2)

boxplot(SE_resids, pch = 20, ylim = c(-20,20))
abline(h = 0, lty = 2)
```




```{r}
#TODO: create a nice way to visualize this
k <- 7
plot(1:32, NE_resids[k, ], type = "l", ylim = range(NE_resids))
lines(1:32, NE_resids[k+1, ], col = "red1")
lines(1:32, NE_resids[k+2, ], col = "orange3")
abline(h = 0, lty = 2)

plot(1:32, SE_resids[k, ], type = "l", ylim = range(SE_resids))
lines(1:32, SE_resids[k+1, ], col = "red1")
lines(1:32, NE_resids[k+2, ], col = "orange3")
abline(h = 0, lty = 2)
```




Fit VAR(MA) model on residuals for both regions


```{r test}
#TODO: delete when done, test block
suppressMessages( library(dplyr))

# Simulate time series data for multiple years (weekly data)
set.seed(123)
years <- rep(2000:2020, each = 52)  # 52 weeks per year
weeks <- rep(1:52, times = length(2000:2020))  # Repeating weeks
values <- rnorm(length(years))  # Simulated data

# Create data frame
df <- data.frame(year = years, week = weeks, value = values)

# Filter only August to December (Weeks 31-52)
df_filtered <- df %>%
  filter(week >= 31 & week <= 52)

# Create a continuous time index ignoring January-July
df_filtered$time_index <- seq_along(df_filtered$value)

ar_model <- ar(df_filtered$value, order.max = 5, method = "yw")
```


```{r VARMA}
#TODO: work out best way to do this with residuals
```


## Logistic HierNet

Using base data


```{r data_update}
#logit data

#group response matrices
#NEAus
NEAus_1 <- logit_NEresp[ ,1:12] #early season
NEAus_2 <- logit_NEresp[ ,13:17] #primary NE fire season
NEAus_3 <- logit_NEresp[ ,18:21] #feedback from SE
NEAus_4 <- logit_NEresp[ ,22:32] #late season

#SEAus
SEAus_1 <- logit_SEresp[ ,1:7] #early season
SEAus_2 <- logit_SEresp[ ,8:16] #feedback from NE
SEAus_3 <- logit_SEresp[ ,17:20] #primary SE fire season
SEAus_4 <- logit_SEresp[ ,21:32] #late season

NEAus_mat <- list(NEAus_1, NEAus_2, NEAus_3, NEAus_4)
SEAus_mat <- list(SEAus_1, SEAus_2, SEAus_3, SEAus_4)

rm(NEAus_1, NEAus_2, NEAus_3, NEAus_4, SEAus_1, SEAus_2, SEAus_3, SEAus_4)

#setup data (resp/preds):
#resp
NElogitresp <- NEresp(NEresp_grouping(NEAus_mat = NEAus_mat, j = 1:19))
SElogitresp <- SEresp(SEresp_grouping(SEAus_mat = SEAus_mat, j = 1:19))

#preds
NEpreds1 <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_std, j = 1:19))
SEpreds1 <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_std, j = 1:19))

#quantile 75 indicator
NE_preds1_q75 <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_q75, j = 1:19))
SE_preds1_q75 <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_q75, j = 1:19))

```

```{r}
i <- 2
y_logit <- SElogitresp[[i]]

#using only nino/dmi
X_1 <- cbind(as.matrix(SEpreds1[[i]][ ,1:104]), as.matrix(SEpreds1[[i]][ ,209:260]),
           as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

#path -> cv -> fit
temp_path <- hierNet.logistic.path( X_1, y_logit, strong = FALSE, diagonal = TRUE)

set.seed(156)
temp_cv <- hierNet.cv(temp_path, X_1, y_logit, nfolds = 5)

plot(temp_cv)

temp_fithat <- hierNet.logistic(X_1, y_logit, lam = temp_cv$lamhat, strong = FALSE, diagonal = TRUE)
temp_fit1se <- hierNet.logistic(X_1, y_logit, lam = temp_cv$lamhat.1se, strong = FALSE, diagonal = TRUE)
```


```{r logit_preds}

k <- 19
#NEpred1 <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_std, j = k))
SE_new <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_std, j = 19))

#quantile 75 indicator
#NEpred1_q75 <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_q75, j = k))
SE_newq75 <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_q75, j = 19))



i <- 2
X_new <- cbind(as.matrix(SE_new[[i]][, 1:104]), as.matrix(SE_new[[i]][ ,209:260]),
           as.matrix(SE_newq75[[i]][, 1:104])  )

log_hat <- predict(temp_fithat, X_new)
log_hat[[1]]
log_hat[[2]]
logit_SEresp[k, 17:32] 

#temp_fit1se$bp - temp_fit1se$bn
```


# glinternet 

Testing and exploring another form of interaction models with lasso

Compare with results from hiernet

```{r test_code}
#TODO: figure out how to make this work with our current data
## build up from smaller data sets

# gaussian response, continuous features
set.seed(155)
Y = rnorm(100)
X = matrix(rnorm(100*10), nrow=100)
numLevels = rep(1, 10)
fit = glinternet(X, Y, numLevels)
coef_test <- coef(fit)
```

```{r test_w/data}
X_test <- NE_preds1[[1]][ ,1:52]
Xtest_q75 <- NE_preds1_q75[[1]][ ,1:52]
y_test <- NE_resp1[[1]]

X_new <- cbind(X_test, Xtest_q75)
  
#sapply(X_test$nino_lag1, nlevels) 
#sapply(test_factor$nino_lag1, nlevels)

num_level <- c(rep(1, length(X_test)), rep(2, length(Xtest_q75)))

#try nino only (first with only continuous data)

set.seed(155)
cv_test <- glinternet.cv(X_new, y_test, numLevels = num_level)

plot(cv_test)
cv_test$lambdaHat1Std
cv_test$lambdaHat

test_index <- which(cv_test$lambdaHat1Std == cv_test$lambda)

sqrt(cv_test$cvErr[[test_index]]) #RMSE

coef_test <- coef(cv_test$glinternetFit)[[test_index]]

coef_test$mainEffects$cont
coef_test$mainEffectsCoef$cont

coef_test$interactions$contcont
coef_test$interactionsCoef$contcont


```


# RAMP 

Using the method from Will's MSEA work but include my indicator functions, repeat previous hierNet work but with RAMP
-Try to replicate the hierNet results here
Note: there will be some changes in that we will use AIC, BIC, or eBIC instead of MSE for lambda selection.

```{r}

```


