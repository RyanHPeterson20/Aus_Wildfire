---
title: "hierNet_test"
author: "Ryan Peterson"
date: "2025-03-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library}
suppressMessages( library(hierNet)) #yes

suppressMessages( library(RAMP)) #maybe

suppressMessages( library( lubridate)) #you know why
```

```{r data_functions}
setwd("~/CO_AUS/Aus_CO-main/Interactions")

#loading in model fits
load( "hiernet_group_split.rda")

#loading in 
load( "hiernet1_group.rda")
```


Testing some additional material/methods

# Out-of-sample

Using split response seasons.

```{r}
#se aus fits
i <- 1
y = as.numeric(SE_resp1[[i]])
X = cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )
coef_namesSE <- c(colnames(SE_preds1[[i]]), paste0( "IND_", colnames(SE_preds1_q75[[i]][ ,1:104]) ) )
colnames(X) <- coef_namesSE

temp_fit <- SE1_fit2[[i]] #lamhat.1se fit

main_effect <- temp_fit$bp - temp_fit$bn
main_terms <- which(main_effect != 0, arr.ind = TRUE)

colnames(X)[main_terms]


interact_effect <- temp_fit$th
interact_terms <- which(interact_effect != 0, arr.ind = TRUE)
interact_names <- matrix(coef_namesSE[interact_terms], nrow = nrow(interact_terms), ncol = ncol(interact_terms))
#interact_names
interact_subterms <- paste0(interact_names[,2], ":", interact_names[,1])
```



# BIC/eBIC

Exploring using an BIC/eBIC methods for lambda selection,

From the RAMP package.
Get log likelihood first
BIC as:
loglik.list + log(n) * df.list
eBIC as:
loglik.list + log(n) * df.list + 2 * ebic.gamma * 
        log(choose(p.eff, df.list))

with: 
 df.list[k] = size.main + size.inter
 p.eff = p + df.m.list *(df.m.list + 1)/2 (for strong hierarchy)
  df.m.list[k] = length(ind.list.main[[k]])
  (Note: size.main = length(ind.list.main[[k]]))
  
```{r functions}
#from RAMP (only Gaussian family)
log.lik <- function(X, y, beta) {
    link = as.vector(X %*% beta)
    n = length(y) 
    return(n * log(mean((y - link)^2)))  
}
```

Since loglik() is n*log(MSE) and the cv.err (from hierNet.cv()) is basically MSE.

Things to explore:
-compare k-fold full fit or coef refit (via glm()) 
-check formal BIC:
$$BIC = k ln(n) - 2 ln(\hat{L})$$
  
```{r}
#testing hierNet.cv (with BIC/eBIC)
i <- 1
y_1 <- as.numeric(SE_resp1[[i]])
X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

#hierNet.cv(fit, x, y, nfolds=5, folds=NULL, trace=0) call
fit <- SE1_path[[i]]
x <- X_1
y <- y_1
nfolds <- 5
trace = 0

errfun=function(y,yhat){(y-yhat)^2}

n <- length(y)
folds <- split(sample(1:n), rep(1:nfolds, length = n))

lamlist=fit$lamlist
stand.main <- !is.null(fit$sx)
stand.int <- !is.null(fit$szz)

n.lamlist <- length(lamlist)
err2 = matrix(NA, nrow=nfolds, ncol=length(lamlist))

for(ii in 1:nfolds) {
#ii <- 1
  
  a <- hierNet.path(x[-folds[[ii]],],y=y[-folds[[ii]]], 
                          lamlist=lamlist, delta=fit$delta, diagonal=fit$diagonal, strong=fit$strong, trace=trace,
                          stand.main=stand.main, stand.int=stand.int,
                          rho=fit$rho, niter=fit$niter, sym.eps=fit$sym.eps, # ADMM parameters (which will be NULL if strong=F)
                          step=fit$step, maxiter=fit$maxiter, backtrack=fit$backtrack, tol=fit$tol) # GG descent params
        
  yhatt = predict(a,newx=x[folds[[ii]],]) #predict.hierNet
  
      
  temp = matrix(y[folds[[ii]]],nrow=length(folds[[ii]]),ncol=n.lamlist)
  err2[ii,] = colMeans(errfun(yhatt,temp))
}

#TODO: work in BIC/eBIC get log(n) and  size.main + size.inter
## cut in more work from RAMP.
nonzero = colSums(fit$bp-fit$bn!=0) + apply(fit$th!=0, 3, function(a) sum(diag(a)) + sum((a+t(a)!=0)[upper.tri(a)]))
#nozero as size.main + size.inter
test.n <- length(y[folds[[ii]]])
test.n * log(err2[ii,]) + log(test.n) * nonzero
errm

  errm=colMeans(err2)
  errse=sqrt(apply(err2,2,var)/nfolds)
  o=which.min(errm)
```

```{r}
i <- 1
y_1 <- as.numeric(SE_resp1[[i]])
X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

#hierNet.cv(fit, x, y, nfolds=5, folds=NULL, trace=0) call
fit <- SE1_path[[i]]

full_yhat <- predict(fit, X_1)
temp = matrix(y_1, nrow=length(y_1), ncol=n.lamlist)

mse <- colMeans(errfun(full_yhat, temp))



#compare to other loop method
y_1 <- as.numeric(SE_resp1[[i]])
#seresp_new <- c(seresp_new, y_1)

X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
           as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

yhat <- predict(SE1_fit2[[i]], X_1)

```

## RAMP BIC/eBIC Methods

Full exploration of the RAMP function

```{r ramp}
#outside (hierNet) fit
i <- 2
fit <- SE1_path[[i]]
lamlist <- fit$lamlist
n.lambda <- length(lamlist)

#function parameters
y = as.numeric(SE_resp1[[i]])
X = cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )
hier = "Strong"
eps = 1e-15
family = "gaussian"


#dimensions of data (n) and parameters (p)
n = dim(X)[1]
p = dim(X)[2]


#prep variables
beta = rep(0, p)  ##the current beta estimates excluding the interation terms
index = NULL

#if (family == "gaussian") {
max.lam = max(abs((1/n) * (t(X) %*% (y - mean(y)))))
a0list = rep(mean(y), n.lambda) #not sure why this is here yet
a0 = a0list[1]


### find the candidate interation effects following strong heredity strong heredity
aa = outer(index, index, f <- function(x, y) {
    paste("X", pmin(x, y), "X", pmax(x, y), sep = "")
})
aa = as.vector(aa)
newinter = outercprod(X0[, index], X0[, index])
bb = unique(as.vector(aa))

#TODO: fit in between these lines

#get this working
curInter = colnames(X)[-(1:p)]
candInter = setdiff(bb, curInter)

ncandInter = length(candInter)
# nonPen[index] = 1 Xinter = NULL
#if (ncandInter > 0 && inter) {
    xnewname = c(colnames(X), candInter)
    tmp = scale(newinter)
    X  = cbind(X,tmp)


#set beta from fit (main effects)
beta_mat <- fit$bp - fit$bn #beta matrix with ncol = n.lambda

#k <- 6 #equivalent to cv lamhat 1se

k <- 7
beta <- beta_mat[ ,k]

index = which(abs(beta[1:p]) > eps)

beta[index]
#a0 = out$beta[p], beta = out$beta[-p] #from cd.general outputs

index = sort(index)
#beta, a0
beta.n = beta 
a0.n = a0 #intercept vector of length(lambda).
```


```{r}
#TODO: get the interaction terms working in this
#work backwards from this
#if (refit == TRUE & length(index) > 0 ) {
  lmfit = glm(y ~ X[,index], family = family)
  beta.lmfit = coef(lmfit)
  #a0.n = beta.lmfit[1]
  beta.n[index] = beta.lmfit[-1]
beta[index]
beta.n[index]
beta.lmfit
```


```{r silly_plots}
plot(1:length(index), beta[index], pch = 16, ylim = range(beta, beta.n))
points(1:length(index), beta.n[index], pch = 17, col = "darkmagenta")
abline(h = 0, lty =2)
```



# Fit (in-sample)

```{r}
NEseason <- list()
SEseason <- list()

for (k in 1:19) {
  #k <- 1
    
  NEpred_test <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_std, j = k))
  SEpred_test <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_std, j = k))
  
  NEresp_test <- NEresp( NEresp_grouping(NEAus_mat = NEAus_mat, j = k))
  SEresp_test <- SEresp( SEresp_grouping(SEAus_mat = SEAus_mat, j = k))
  
  #quantile 75 indicator
  NEpredq75_test <- NEpreds( NElag_grouping(NE_laglist = NE_laglist_q75, j = k))
  SEpredq75_test <- SEpreds( SElag_grouping(SE_laglist = SE_laglist_q75, j = k))
  
  ne_yhat <- list()
  neresp_new <- c()
  n <- length(NEresp_test)
  for (i in 1:n) {
    y_1 <- as.numeric(NEresp_test[[i]])
    neresp_new <- c(neresp_new, y_1)
    
    X_1 <- cbind(as.matrix(NEpred_test[[i]][ ,1:260]),
               as.matrix(NEpredq75_test[[i]][ ,1:104])  )
    yhat <- predict(NE1_fit1[[i]], X_1)
    
    ne_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  se_yhat <- list()
  seresp_new <- c()
  n <- length(SEresp_test)
  for (i in 1:n) {
    y_1 <- as.numeric(SEresp_test[[i]])
    seresp_new <- c(seresp_new, y_1)
    
      
    X_1 <- cbind(as.matrix(SEpred_test[[i]][ ,1:260]),
               as.matrix(SEpredq75_test[[i]][ ,1:104])  )
    
    yhat <- predict(SE1_fit1[[i]], X_1)
    
    se_yhat[[paste0("Group_", i)]] <- yhat
  }
  
  y_nehat <- c(ne_yhat[[1]], ne_yhat[[2]])
  y_sehat <- c(se_yhat[[1]], se_yhat[[2]])
  
  NEseason[[paste0("Season_", seasons[k])]] <- y_nehat
  SEseason[[paste0("Season_", seasons[k])]] <- y_sehat
}

```


```{r}
#extract seasons
new_resp <- bounded_resp_df[which(bounded_resp_df$week %in% season_weeks, arr.ind = TRUE), ]
new_resp <- new_resp[-c(1:14), ]

#setup vertical year lines
unique_yr <- unique(year(new_resp$time))
year_lines <- c(unique_yr[1:length(unique_yr)])
year_lines <- paste0(year_lines, "0101")
year_lines <- as_date(year_lines)

#year_text <- year_lines
#year_text <- as_date(year_text) + months(6)
year_text <- year_lines + months(6)

xlim_val <- ymd(c("20010829", "20200401"))

temp_NE <- scale(new_resp$NE_Aus_anomaly_co, center = TRUE, scale = FALSE) 
temp_SE <- scale(new_resp$SE_Aus_anomaly_co, center = TRUE, scale = FALSE) 
temp_time <- as.Date(new_resp$time)

#prediction data:
NE_hat <- c()
SE_hat <- c()
for (i in 1:19) {
  NE_hat <- c(NE_hat, NEseason[[i]])
  SE_hat <- c(SE_hat, SEseason[[i]])
}

#region DFs
NEAUS_df <- data.frame(time = temp_time, true = temp_NE, pred = NE_hat)
SEAUS_df <- data.frame(time = temp_time, true = temp_SE, pred = SE_hat)

#full plots
  
setwd("~/CO_AUS/Aus_CO-main/Interactions")
  
png(filename = "NEAUSpreds_new.png", width = 2400, height = 1100, res = 200)
par(mar = c(3,5,4,1))
plot(x = NEAUS_df$time, y = NEAUS_df$true, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1.33,
     xaxt = "n",  xlab = "",
     ylab = "CO Anomaly", 
     main = "NE Aus : Predictions")
points(x = NEAUS_df$time, y = NEAUS_df$pred, pch = 17, 
     col = "magenta3", cex = 1)
abline(v = year_lines[-1], lty = 2)
abline(h = 0, lty = 2)
legend("bottomleft", inset = c(0.00, 0),
       legend = c("True", "Pred"),
       col = c("black", "magenta3"),
       pch = c(18,17),
       pt.cex = c(1.33,1))
axis(side = 1, at = year_text, labels = unique_yr, tick = FALSE, cex.axis = 1)
dev.off()

png(filename = "SEAUSpreds_new.png", width = 2400, height = 1100, res = 200)
par(mar = c(3,5,4,1))
plot(x = SEAUS_df$time, y = SEAUS_df$true, pch = 18, 
     col = "black", xlim = xlim_val, cex = 1.33,
     xaxt = "n",  xlab = "",
     ylab = "CO Anomaly", 
     main = "SE Aus : Predictions")
points(x = SEAUS_df$time, y = SEAUS_df$pred, pch = 17, 
     col = "magenta3", cex = 1)
abline(v = year_lines[-1], lty = 2)
abline(h = 0, lty = 2)
legend("bottomleft", inset = c(0.00, 0),
       legend = c("True", "Pred"),
       col = c("black", "magenta3"),
       pch = c(18,17),
       pt.cex = c(1.33,1))
axis(side = 1, at = year_text, labels = unique_yr, tick = FALSE, cex.axis = 1)
dev.off()
```


```{r}
test_fit <- a

new_nonzero <- colSums(test_fit$bp-test_fit$bn!=0) + apply(test_fit$th!=0, 3, function(a) sum(diag(a)) + sum((a+t(a)!=0)[upper.tri(a)]))

test.n <- length(y[folds[[ii]]])
test.n * log(err2[ii,]) + log(test.n)*new_nonzero
```

# RAMP Test

```{r}
i <- 2
y = as.numeric(SE_resp1[[i]])
X = cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

ramp.fit <- RAMP::RAMP(X = X, y = y,
                             penalty = "LASSO",
                             tune = "EBIC",
                             n.lambda = 100,
                             ebic.gamma = 1) 

main_terms <- ramp.fit$mainInd
int_terms <- ramp.fit$interInd
this.term <- int_terms[1]
as.integer(strsplit(this.term, "X")[[1]][2:3])


ramp.fit$cri.loc
ramp.fit$cri.list[ramp.fit$cri.loc]
```



```{r test_block}
n = dim(x)[1]
p = dim(x)[2]
```

