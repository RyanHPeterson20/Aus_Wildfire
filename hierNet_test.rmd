---
title: "hierNet_test"
author: "Ryan Peterson"
date: "2025-03-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library}
suppressMessages( library(hierNet)) #yes

suppressMessages( library(RAMP)) #maybe


```

```{r data_functions}
setwd("~/CO_AUS/Aus_CO-main/Interactions")

#loading in model fits
load( "hiernet_group_split.rda")

#
```


Testing some additional material/methods


# BIC/eBIC

Exploring using an BIC/eBIC methods for lambda selection,

From the RAMP package.
Get log likelihood first
BIC as:
loglik.list + log(n) * df.list
eBIC as:
loglik.list + log(n) * df.list + 2 * ebic.gamma * 
        log(choose(p.eff, df.list))

with: 
 df.list[k] = size.main + size.inter
 p.eff = p + df.m.list *(df.m.list + 1)/2 (for strong hierarchy)
  df.m.list[k] = length(ind.list.main[[k]])
  (Note: size.main = length(ind.list.main[[k]]))
  
```{r functions}
#from RAMP (only Gaussian family)
log.lik <- function(X, y, beta) {
    link = as.vector(X %*% beta)
    n = length(y) 
    return(n * log(mean((y - link)^2)))  
}
```

Since loglik() is n*log(MSE) and the cv.err (from hierNet.cv()) is basically MSE.

Things to explore:
-compare k-fold full fit or coef refit (via glm()) 
-check formal BIC:
$$BIC = k ln(n) - 2 ln(\hat{L})$$
  
```{r}
#testing hierNet.cv (with BIC/eBIC)
i <- 1
y_1 <- as.numeric(SE_resp1[[i]])
X_1 <- cbind(as.matrix(SE_preds1[[i]][ ,1:260]),
             as.matrix(SE_preds1_q75[[i]][ ,1:104])  )

#hierNet.cv(fit, x, y, nfolds=5, folds=NULL, trace=0) call
fit <- SE1_path[[i]]
x <- X_1
y <- y_1
nfolds <- 5
trace = 0

errfun=function(y,yhat){(y-yhat)^2}

n <- length(y)
folds <- split(sample(1:n), rep(1:nfolds, length = n))

lamlist=fit$lamlist
stand.main <- !is.null(fit$sx)
stand.int <- !is.null(fit$szz)

n.lamlist <- length(lamlist)
err2 = matrix(NA, nrow=nfolds, ncol=length(lamlist))

#for(ii in 1:nfolds) {
ii <- 1

a <- hierNet.path(x[-folds[[ii]],],y=y[-folds[[ii]]], 
                        lamlist=lamlist, delta=fit$delta, diagonal=fit$diagonal, strong=fit$strong, trace=trace,
                        stand.main=stand.main, stand.int=stand.int,
                        rho=fit$rho, niter=fit$niter, sym.eps=fit$sym.eps, # ADMM parameters (which will be NULL if strong=F)
                        step=fit$step, maxiter=fit$maxiter, backtrack=fit$backtrack, tol=fit$tol) # GG descent params
      
yhatt = predict(a,newx=x[folds[[ii]],]) #predict.hierNet

    
temp = matrix(y[folds[[ii]]],nrow=length(folds[[ii]]),ncol=n.lamlist)
err2[ii,] = colMeans(errfun(yhatt,temp))
#}

#TODO: work in BIC/eBIC get log(n) and  size.main + size.inter
nonzero = colSums(fit$bp-fit$bn!=0) + apply(fit$th!=0, 3, function(a) sum(diag(a)) + sum((a+t(a)!=0)[upper.tri(a)]))
#nozero as size.main + size.inter
test.n <- length(y[folds[[ii]]])
test.n * log(err2[ii,]) + log(test.n) * nonzero

```



```{r test_block}
n = dim(x)[1]
p = dim(x)[2]
```

