---
title: "integrationtest_cbs"
author: "Ryan Peterson"
date: "2025-02-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library}
suppressMessages( library(LatticeKrig))

#parallel packages for integration
suppressMessages(library(foreach))
suppressMessages(library(parallel))
suppressMessages(library(doParallel))

#color
suppressMessages(library(scales))

#timing
suppressMessages(library(tictoc))
```


```{r data_functions}
#bring in the data and functions we need
setwd("~/COS_LK/CubicBSpline")

source("R/CubicBSpline.R")
source("R/new_basisintegral.R")

load("Data/integration_testdata.rda")
```


```{r new_fucntions}

cdf_bspline <- function(d){
  d <- d*2
  
  return((1/24) *(pmax(d + 2, 0)^4 - 4 * (pmax(d + 1, 0)^4) + 6 * (pmax(d, 0)^4) -
                   4 * (pmax(d - 1, 0)^4)) * (abs(d) <= 2))
}

rect_intercept <- function(poly1, poly2){

  #we may not need this, check later
  xd <- poly1[ ,1]
  yd <- poly1[ ,2]
  
  xp <- poly2[ ,1]
  yp <- poly2[ ,2]
  
  xmin_int <- max(min(xd), min(xp))
  ymin_int <- max(min(yd), min(yp))
  xmax_int <- min(max(xd), max(xp))
  ymax_int <- min(max(yd), max(yp))
  
  new_poly <- matrix(c(xmin_int, ymin_int, 
                             xmax_int, ymin_int, 
                             xmax_int, ymax_int, 
                             xmin_int, ymax_int,
                             xmin_int, ymin_int), ncol = 2, byrow = TRUE)
  return(new_poly)
}

```

```{r exploration}
x1 <- seq(-1,1,,100)
cdf_out <- cdf_bspline(x1)

plot(x1, cdf_out, type = "l")
plot(diff(cdf_out)/(.05), type = "l")
plot(diff(diff(cdf_out)), type = "l")
plot(diff(diff(diff(cdf_out))), type = "l")
```

```{r lk setup}
#LK setup
s_new <- cbind(sub1_df$x, sub1_df$y)
z_new <- cbind(sub1_df$look_stat)

sDomain <- sDomain <- cbind(c(-5,5),
                 c(-5,5))

LK_info <- LKrigSetup(sDomain, NC=15, nlevel=1, a.wght=4.1, overlap = 2, NC.buffer = 2, nu = 1,
                      LKGeometry="LKRectangle", BasisFunction = "CubicBSpline", 
                      BasisType = "Tensor", normalize = FALSE)

LKinfo_base <- LKrigSetup(sDomain, NC=15, nlevel=1, a.wght=4.1, overlap = 2.5, NC.buffer = 2, nu = 1,
                      LKGeometry="LKRectangle", 
                      BasisType = "Radial", normalize = FALSE)


```


```{r testing_block}
x_1 <- seq(-2, -1, ,200)
x_2 <- seq(-1, 0, ,200)
x_3 <- seq(0, 1, ,200)
x_4 <- seq(1, 2, ,200)

y_1 <- seq(-2, -1, ,200)
y_2 <- seq(-1, 0, ,50)

x1_out <- CubicBSpline(x_1/2)
x2_out <- CubicBSpline(x_2/2)
x3_out <- CubicBSpline(x_3/2)
x4_out <- CubicBSpline(x_4/2)



y1_out <- CubicBSpline(y_1/2)
y2_out <- CubicBSpline(y_2/2)

plot(y_2, y2_out, type = "b")

int_x <- cdf_bspline(x_1)
int_y <- cdf_bspline(y_1)

x1y_out <- outer(x1_out, y1_out, "*")
x2y_out <- outer(x2_out, y1_out, "*")
x3y_out <- outer(x3_out, y1_out, "*")
x4y_out <- outer(x4_out, y1_out, "*")

x1y2_out <- outer(x1_out, y2_out, "*")
x2y2_out <- outer(x2_out, y2_out, "*")
x3y2_out <- outer(x3_out, y2_out, "*")

int_xy <- outer(int_x, int_y, "*")

#image.plot(x1y_out)
#image.plot(x2y_out)
#image.plot(x3y_out)
#image.plot(x4y_out)

#image.plot(x1y2_out)
#image.plot(x2y2_out)
image.plot(x3y2_out)

#image.plot(int_xy)

#TODO: full numeric integration (from basisIntegral)
#sum(zGrid[inside])  * dx * dy
    
#integral delta
#dx <- x_1[2] - x_1[1]  
#dy <- y_1[2] - y_1[1]

#plot(x_1, x1_out, type = "l")
#lines(x_1, int_x, col = "red2", lty = 2)

#cdf_x1 <- cdf_bspline(max(x_1)) - cdf_bspline(min(x_1))
#cdf_x2 <- cdf_bspline(max(x_2)) - cdf_bspline(min(x_2))
cdf_x3 <- cdf_bspline(max(x_3)) - cdf_bspline(min(x_3))

#cdf_y1 <- cdf_bspline(max(y_1)) - cdf_bspline(min(y_1))
cdf_y2 <- cdf_bspline(max(y_2)) - cdf_bspline(min(y_2))

#cdf_x * cdf_y
#cdf_x1 * sum(y_out) *dy
#sum(x1y_out) * dx * dy

#cdf_x2 * sum(y_out) * dy
#sum(x2y_out) * dx * dy

#cdf_x3 * sum(y_out) * dy
#sum(x3y_out) * dx * dy
dx3 <- x_3[2] - x_3[1]  
dy2 <- y_2[2] - y_2[1]


sum(y2_out) *dy2

cdf_x3 * cdf_y2
cdf_x3 * sum(y2_out) *dy2
sum(x3y2_out) * dx3 * dy2


#TODO: show volume under surface, compare between full analytic, full numeric, and mix. (why did I want to do this?)

```


```{r bivariate_cdf}
#TODO: create nice visualization of bivariate (tensor product) cdf


x_full <- seq(-2, 2, ,200)
y_full <- seq(-2, 2, ,200)

cdf_x <- cdf_bspline(x_full)
cdf_y <- cdf_bspline(y_full)

#TODO output as png/pdf
image.plot(outer(cdf_x, cdf_y, "*"))
```


# Rectangular Polygons

For work in rectangular polygons only so that:
$$\int_c^d \int_a^b \phi(x)\phi(y)dxdy = (\Phi(b)-\Phi(a))(\Phi(d)-\Phi(c)).$$


```{r new_basis_integral_build}
#some setup
boundingBox<- rbind( c( -1,-1),
                     c( 1,-1),
                     c( 1,1),
                     c( -1, 1),
                     c( -1,-1))

#rectangular polygons (256 polygons)
#test polygons 3, 35, 51
j <- 373
poly_temp <- polyGroups[[j]]

#we do not need a grid

#we can extract min and max from range
#TODO: consider this for a `vector' of polygons (i.e., pmax, pmin)
x_range <- range(poly_temp[,1]) 
y_range <- range(poly_temp[,2])

#TODO: determine which basis functions a given polygon fit into
LKinfo <- LK_info
L <- 1 #level
# get info for the L^th level of the multi-resolution basis. 
basisIndex <- (1:LKinfo$latticeInfo$mLevel[L])
basisOffset <- LKinfo$latticeInfo$offset[L]
basisScale <- LKinfo$latticeInfo$delta[L]*LKinfo$basisInfo$overlap
basisGridList <- LKinfo$latticeInfo$grid[[L]]
basisCenters <- make.surface.grid(basisGridList)





k <- 145 #test k = 59, 44
polyStd <-
  cbind((poly_temp[, 1] - basisCenters[k, 1]) / basisScale,
        (poly_temp[, 2] - basisCenters[k, 2]) / basisScale)

# consider the below but do quandrants between basisCenters
##create boundingboxes from grid points
allOutside <- fields::in.poly(  polyStd, boundingBox) #example
allOutside
sum(allOutside)
#conditionals for which 
if (sum(allOutside) > 0) {
  
  if(sum(allOutside) < 5){
    #get intercepts
    polyNew <- rect_intercept(polyStd, boundingBox)
    

    xRange_new <- round(range(polyNew[,1]), 8) 
    yRange_new <- round(range(polyNew[,2]), 8)
    
    integral_x <- cdf_bspline(xRange_new[2])-cdf_bspline(xRange_new[1])
    integral_y <- cdf_bspline(yRange_new[2])-cdf_bspline(yRange_new[1])
    
    integral_x*integral_y*basisScale
    
  } else  {
    xRange_std <- range(polyStd[,1]) 
    yRange_std <- range(polyStd[,2])
    
    (cdf_bspline(xRange_std[2])-cdf_bspline(xRange_std[1]))*(cdf_bspline(yRange_std[2])-cdf_bspline(yRange_std[1]))*basisScale
  }
  
}
##


#TODO: look into... (something. I forgot after writing this.)
```

```{r}

    xRange_new <- round(range(polyNew[,1]), 8)
    yRange_new <- round(range(polyNew[,2]), 8)
    
    integral_x <- cdf_bspline(xRange_new[2])-cdf_bspline(xRange_new[1])
    integral_y <- cdf_bspline(yRange_new[2])-cdf_bspline(yRange_new[1])
    
    xRange_new
    yRange_new[2]
    
    cdf_bspline(max(polyNew[,2]))
    cdf_bspline(min(polyNew[,2]))
    integral_y
    
    test.for.zero(yRange_new[2], yRange_new[1])
    test.for.zero(max(polyNew[,2]), min(polyNew[,2]))
    test.for.zero(max(polyNew[,2]), 1)
    test.for.zero(min(polyNew[,2]), 1)
    
    cdf_bspline(1)
  
```


```{r}
#direct cdf_bspline test

d <- yRange_new[2]
d <- d*2

abs(d) <= 2
(1/24) *(pmax(d + 2, 0)^4 - 4 * (pmax(d + 1, 0)^4) + 6 * (pmax(d, 0)^4) -
                   4 * (pmax(d - 1, 0)^4))
```


```{r polygon_check}
tic()
X_1<- basisIntegral_rect(polyGroups, LK_info)
toc()
X_1<- spind2spam(X_1)

X_full <- spam2full(X_1)
```

```{r}
#get a single basis function
which(X_full[ ,145] != 0, arr.ind = TRUE)
```



```{r new_test}
#test polygons 3, 35, 51
j <- 51
poly_temp <- polyGroups[j]

out <- basisIntegral_rect(poly_temp, LK_info)

out_full <- spind2full(out)

out_full[45]
```


```{r full_test}
tic()
out <- basisIntegral_rect(polyGroups, LK_info)
toc()
```


```{r }
tic()
out_base <- basisIntegral(polyGroups, LKinfo_base, M = 200)
toc()

tic()
out_par <- basisIntegral_New( polyGroups, LKinfo_base, M = 200, cores = 8, normalize = FALSE)
toc()
```


```{r in_poly}
#create simple rectangle intercept function
#using code from in.poly
rect_intercept <- function(poly1, poly2){

  #we may not need this, check later
  xd <- poly1[ ,1]
  yd <- poly1[ ,2]
  
  xp <- poly2[ ,1]
  yp <- poly2[ ,2]
  
  xmin_int <- max(min(xd), min(xp))
  ymin_int <- max(min(yd), min(yp))
  xmax_int <- min(max(xd), max(xp))
  ymax_int <- min(max(yd), max(yp))
  
  new_poly <- matrix(c(xmin_int, ymin_int, 
                             xmax_int, ymin_int, 
                             xmax_int, ymax_int, 
                             xmin_int, ymax_int,
                             xmin_int, ymin_int), ncol = 2, byrow = TRUE)
  
  return(new_poly)
}

#test section
polyStd
boundingBox

out <- rect_intercept(polyStd, boundingBox)

plot(boundingBox, type = "l", xlim = range(polyStd[,1], boundingBox[,1]))
polygon(polyStd, border = "magenta3")
points(out)

xd <- polyStd[ ,1]
yd <- polyStd[ ,2]

xp <- boundingBox[ ,1]
yp <- boundingBox[ ,2]

#poly1 <- c(min(xd), min(yd), max(xd), max(yd))
#poly2 <- c(min(xp), min(yp), max(xp), max(yp))

xmin_int <- max(min(xd), min(xp))
ymin_int <- max(min(yd), min(yp))
xmax_int <- min(max(xd), max(xp))
ymax_int <- min(max(yd), max(yp))

new_poly <- matrix(c(xmin_int, ymin_int, 
                           xmax_int, ymin_int, 
                           xmax_int, ymax_int, 
                           xmin_int, ymax_int,
                           xmin_int, ymin_int), ncol = 2, byrow = TRUE)

```


```{r}
Xindex <- which(X_full[ ,145] != 0, arr.ind = TRUE)
#poly_temp <- polyGroups[Xindex[c(8, 16, 24,32,40,48,56)]]

#Xindex[c(8, 15, 23,31,39,47,55)]

poly_temp <- polyGroups[Xindex]
#poly_new <- poly_temp[-c(8, 16, 24,32,40,48,56)]

poly_vals <- X_full[Xindex, 145]
range(poly_vals)
#vals_new <- poly_vals[-c(8, 15, 23,31,39,47,55)]
#range(vals_new)

#plot(basisCenters, xlim = c(-6.25, -2.5), ylim = c(-5.25, -2.5), pch = 16, cex = 0.67)
#polygon(polyTmp, border="darkmagenta", lwd = 0.5)

layout<-setupLegend()
plot(basisCenters,  pch = 16, cex = 0.67, xlim = c(-1, 4), ylim = c(-3.5, 1))
yline(basisGridList$y)
xline(basisGridList$x)
#polygon(poly_temp, border="darkmagenta", lwd = 2)
#points(basisCenters[30, 1], basisCenters[30,2], pch = 16, col = "blue2")
cScale<- alpha(turbo(256), 0.85)
cTab<- color.scale(poly_vals, cScale)
points(basisCenters[145, 1], basisCenters[145,2], pch = 16, col = "red2")
for ( k in 1:length(poly_temp)){
  polyTmp<- poly_temp[[k]]
  polygon(polyTmp, border="magenta3", lwd=1, col = cTab[k])
}
addLegend(layout, col=alpha(turbo(256),.95), zlim= range(poly_vals ))


#points(basisCenters[59, 1], basisCenters[59,2], pch = 16, col = "green3")

```


```{r new_basis_function}
basisIntegral_rect <- function(polyGroups, LKinfo){
  
  nLevel <- LKinfo$nlevel
  
  boundingBox<- rbind( c( -1,-1),
                       c( 1,-1),
                       c( 1,1),
                       c( -1, 1),
                       c( -1,-1))  
  
  # total number of polygons
  N1 <- length(polyGroups)
  
  # total number of basis functions
  N2 <- LKinfo$latticeInfo$m
  
  # basis function scales
  delta <- LKinfo$latticeInfo$delta
  integral <- NULL
  J <- NULL
  K <- NULL
  
  #TODO: change to foreach (parallel later)
  for (j in 1:N1) {
    
    polyTmp <- polyGroups[[j]]
    
    for (L in 1:nLevel) {
      # get info for the L^th level of the multi-resolution basis. 
      basisIndex <- (1:LKinfo$latticeInfo$mLevel[L])
      basisOffset <- LKinfo$latticeInfo$offset[L]
      basisScale <- LKinfo$latticeInfo$delta[L]*LKinfo$basisInfo$overlap
      basisGridList <- LKinfo$latticeInfo$grid[[L]]
      basisCenters <- make.surface.grid(basisGridList)
      
      for (k in basisIndex){
        # k is position at the L^th level
        
        polyStd <-
          cbind((polyTmp[, 1] - basisCenters[k, 1]) / basisScale,
                (polyTmp[, 2] - basisCenters[k, 2]) / basisScale)
        
        allOutside <- in.poly(polyStd, boundingBox)
        
        if(sum(allOutside) > 0 ){
          
          if(sum(allOutside) < 5){
            #get intercepts
            polyNew <- rect_intercept(polyStd, boundingBox)
            
            xRange_new <- range(polyNew[,1]) 
            yRange_new <- range(polyNew[,2])
            
            tmpIntegral <- (cdf_bspline(xRange_new[2])-cdf_bspline(xRange_new[1]))*(cdf_bspline(yRange_new[2])-cdf_bspline(yRange_new[1]))*basisScale
            
          } else  {
            xRange_std <- range(polyStd[,1]) 
            yRange_std <- range(polyStd[,2])
            
            tmpIntegral <- (cdf_bspline(xRange_std[2])-cdf_bspline(xRange_std[1]))*(cdf_bspline(yRange_std[2])-cdf_bspline(yRange_std[1]))*basisScale
          }
          
            #spind set-up
            J <- c(J, j)
            K <- c(K, k + basisOffset) # offset adjusts for preceding levels. 
            integral <- c(integral, tmpIntegral)
        }  
        
      }
    }  
  }
  
  # spind sparse format.
  obj<- list( ind= cbind( J,K), ra= integral, 
              da= c( N1,N2))
 
  return(obj)
}

```


```{r basis_integral}
#basis integral function test

#parameter setup
#set polygon to be an entire
#polyGroups_test <- 

polyGroups <- polygon_subset
LKinfo <- LK_info
M <- 200
check <- TRUE 
  
nLevel <- LKinfo$nlevel
gridList <- list(x = seq(-1, 1, length.out = M),
                 y = seq(-1, 1, length.out = M))

boundingBox<- rbind( c( -1,-1),
                     c( 1,-1),
                     c( 1,1),
                     c( -1, 1),
                     c( -1,-1))

dx<- gridList$x[2]- gridList$x[1]
dy<- gridList$y[2]- gridList$y[1]

# integral for standard basis function.
xyGrid <- make.surface.grid(gridList)
plot(xyGrid, pch =16, cex = 0.2) #check grid

yGrid <- CubicBSpline(gridList$y)
xGrid <- CubicBSpline(gridList$x)


plot(gridList$y, yGrid, type = "l")
xline(seq(-1,1,0.5))

plot(gridList$x, xGrid, type = "l")
xline(seq(-1,1,0.5))

#previous wendland setup
zGrid <- Wendland(sqrt(xyGrid[, 1] ^ 2 + xyGrid[, 2] ^ 2), dimension = 2, k = 2)

#TODO: repeat for tensor b-spline (for comparison)
#stdIntegral<- sum( zGrid)*dx*dy

# total number of polygons
N1 <- length(polyGroups)

# total number of basis functions
N2 <- LKinfo$latticeInfo$m

# basis function scales
delta <- LKinfo$latticeInfo$delta

#for (j in 1:N1) {
# loop over the polygon regions (This could be parallelized using a foreach constuct. )


j <- 1
polyTmp <- (polyGroups)[[j]]
#change polyTmp to be an entire quadrant of the basis function
#polyTmp <-  rbind(  c(basisGridList$x[3], basisGridList$y[3]),
#                    c(basisGridList$x[3], basisGridList$y[4]),
#                    c(basisGridList$x[4], basisGridList$y[4]),
#                    c(basisGridList$x[4], basisGridList$y[3]),
#                    c(basisGridList$x[3], basisGridList$y[3]))

#for (L in 1:nLevel) {
L <- 1

# get info for the L^th level of the multi-resolution basis. 
basisIndex <- (1:LKinfo$latticeInfo$mLevel[L])
basisOffset <- LKinfo$latticeInfo$offset[L]
basisScale <- LKinfo$latticeInfo$delta[L]*LKinfo$basisInfo$overlap
basisGridList <- LKinfo$latticeInfo$grid[[L]]
basisCenters <- make.surface.grid(basisGridList)


plot(basisCenters, xlim = c(-6.25, -3.5), ylim = c(-5.25, -2.5), pch = 16, cex = 0.67)
#polygon(polyTmp, border="darkmagenta", lwd = 0.5)
yline(basisGridList$y)
xline(basisGridList$x)
polygon(polyTmp, border="darkmagenta", lwd = 1.5)
points(basisCenters[45, 1], basisCenters[45,2], pch = 16, col = "red2")
```


```{r }
#for (k in basisIndex){
# k is position at the L^th level
k <- 45

#TODO: rename and change (maybe)
polyStd <-
  cbind((polyTmp[, 1] - basisCenters[k, 1]) / basisScale,
        (polyTmp[, 2] - basisCenters[k, 2]) / basisScale)


#TODO: visualize the shift by showing original relationship and std relationship (between polygon and basis)
plot(xyGrid, pch =16, cex = 0.2) 
polygon(polyStd,  border="magenta3")


inside <- fields::in.poly(xyGrid, polyStd)
            #TODO: optimize this later
grid_inside <- xyGrid[inside,]
test_y <- unique(grid_inside[,2])
x_range <- range(grid_inside[,1])


#inside <- fields::in.poly.grid(gridList, polyStd)

inside_test <- fields::in.poly(xyGrid, polyStd)
test_inside <- xyGrid[inside_test,]
test_y <- unique(test_inside[,2])

#gridList$y[51]
#test_y[1]
#gridList$y %in% test_y
#which(gridList$y %in% test_y)

#TODO: explore y axis points
in_grid <- which(gridList$y %in% test_y)
y_out <- yGrid[in_grid]
plot(test_y, y_out, type = "b")

y_range <- range(test_inside[,2])
x_range <- range(test_inside[,1])

true_x <- range(polyStd[,1])
true_y <- range(polyStd[,2])

cdf_bspline(true_x[2]*2)-cdf_bspline(true_x[1]*2)
cdf_bspline(x_range[2]*2)-cdf_bspline(x_range[1]*2)

cdf_bspline(true_y[2]*2)-cdf_bspline(true_y[1]*2)
sum(yGrid[ which(gridList$y == test_y)])*dy*2

#test true?
(cdf_bspline(true_x[2]*2)-cdf_bspline(true_x[1]*2))*(cdf_bspline(true_y[2]*2)-cdf_bspline(true_y[1]*2))

sum(yGrid[ which(gridList$y == test_y)])*dy*(cdf_bspline(x_range[2]*2)-cdf_bspline(x_range[1]*2))*basisScale

#TODO: get intercepts from polygon


plot(xyGrid, pch =16, cex = 0.25,
     xlim = c(-0.1, 0.6), ylim = c(-0.6, 0.1)) 
polygon(polyStd,  border="magenta3")
points(test_inside[1:22,], pch = 16, col = "darkmagenta")

range(test_inside[,2])
test_y <- unique(test_inside[,2])




#test_inside[test_inside[,2] == test_y, 1]

min(test_inside[,2])
max(test_inside[,2])


          
#if (sum(inside) > 0) {
sum(inside_test)


#image.plot(zGrid[inside])
```

```{r poly_int}
#polygon intercept
polyStd <-
  cbind((polyTmp[, 1] - basisCenters[k, 1]) / basisScale,
        (polyTmp[, 2] - basisCenters[k, 2]) / basisScale)

polyStd

#x2, (y1, y2) 
x_2 <- polyStd[2:3, 1]
y_2 <- polyStd[2:3, 2]


#x1, (y2, y1)
x_1 <- polyStd[5:4, 1]
y_1 <- polyStd[5:4, 2]

y_int <- -0.4

x_int <- function(y_int, x_val, y_val){
  
  #TODO: add in vector checks
  x_1 <- x_val[1]
  x_2 <- x_val[2]
  
  y_1 <- y_val[1]
  y_2 <- y_val[2]
   
  return(x_1 + ((y_int - y_1)*(x_2 - x_1))/(y_2 - y_1))
}


x_int(y_int, x_2,y_2)
x_int(y_int, x_1 ,y_1)


#polygon_subset[1]
#if(())
```


```{r function}
#write function in full
basis_integral <- function(polyGroups, LKinfo, M = 200, check = TRUE ){
  
  nLevel <- LKinfo$nlevel
  gridList <- list(x = seq(-1, 1, length.out = M),
                   y = seq(-1, 1, length.out = M))
  
  boundingBox<- rbind( c( -1,-1),
                       c( 1,-1),
                       c( 1,1),
                       c( -1, 1),
                       c( -1,-1))
  
  dx<- gridList$x[2]- gridList$x[1]
  dy<- gridList$y[2]- gridList$y[1]
  
  # integral for standard basis function.
  xyGrid <- make.surface.grid(gridList)
  
  #only evaluate wrt y 
  yGrid <- CubicBSpline(gridList$y)
  
  # total number of polygons
  N1 <- length(polyGroups)
  
  # total number of basis functions
  N2 <- LKinfo$latticeInfo$m
  
  # basis function scales
  delta <- LKinfo$latticeInfo$delta
  integral <- NULL
  J <- NULL
  K <- NULL
  
  #TODO: change this to parallel later
  for (j in 1:N1) {
    # loop over the polygon regions (This could be parallelized using a foreach constuct. )
    polyTmp <- polyGroups[[j]]
    
    for (L in 1:nLevel) {
      # get info for the L^th level of the multi-resolution basis. 
      basisIndex <- (1:LKinfo$latticeInfo$mLevel[L])
      basisOffset <- LKinfo$latticeInfo$offset[L]
      basisScale <- LKinfo$latticeInfo$delta[L]*LKinfo$basisInfo$overlap
      basisGridList <- LKinfo$latticeInfo$grid[[L]]
      basisCenters <- make.surface.grid(basisGridList)
    
      for (k in basisIndex){
        # k is position at the L^th level
        
        polyStd <-
          cbind((polyTmp[, 1] - basisCenters[k, 1]) / basisScale,
                (polyTmp[, 2] - basisCenters[k, 2]) / basisScale)
              
        allOutside <- in.poly(polyStd, boundingBox)
        if(sum(allOutside) > 0 ){
          inside <- in.poly(xyGrid, polyStd)
          if (sum(inside) > 0) {
            
            #TODO: optimize this later
            #grid_inside <- xyGrid[inside, ]
            #test_y <- unique(grid_inside[ ,2])
            #x_range <- range(grid_inside[ ,1])
            
            test_y <- unique(xyGrid[inside, 2])
            
            #TODO: replace
            x_range <- range(xyGrid[inside, 1])
            
            in_grid <- which(gridList$y %in% test_y)
            #y_out <- yGrid[in_grid]

            x_out <- cdf_bspline(x_range[2]*2)-cdf_bspline(x_range[1]*2) #integral along x
            
            # note basisScale factor has to be added because this sum is
            # over the  standard basis functions with  scale  1.0
            tmpIntegral <- sum(yGrid[in_grid])*dy*(x_out)*basisScale
            
            #spind set-up
            J <- c(J, j)
            K <- c(K, k + basisOffset) # offset adjusts for preceding levels. 
            integral <- c(integral, tmpIntegral)
          }
        }  
      }
    }  
  }
  # spind sparse format.
  obj<- list( ind= cbind( J,K), ra= integral, 
              da= c( N1,N2))
 
  return(obj)
}
```


```{r function_testing}
polygon_subset <- polyGroups[1:10]
out_test <- basis_integral(polyGroups = polygon_subset, LKinfo = LK_info)

out_full <- spind2full(out_test)
rowSums(out_full)
```


```{r test_block}
x2 <- 1
x1 <- 0
ds <- (x2-x1)

x_t <- function(t) {
  return(x1 + t * (x2 - x1))
}

library(pracma)

integrand <- function(t){
  return(CubicBSpline(x_t(t))*ds)
}

integral(integrand, 0, 1)

cdf_bspline(-1)-cdf_bspline(-2)
cdf_bspline(2)-cdf_bspline(1)
#cdf_bspline(1)
```

