---
title: "IOD_EOF"
author: "Ryan Peterson"
date: "2025-07-16"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
#.nc files
library(ncdf4)
suppressMessages(library(terra))

# date mgmt
suppressMessages(library(lubridate))

#visualization and interpolation
suppressMessages(library(fields))

```

The goal of this document is to reproduce the pIOD indices from Cai et al, 2021

Starting with OISST v2 (NOAA Optimum Interpolation SST version 2)

From .nc data we clean and sort data correctly, the perform appropriate EOF(PCA), then get S-pIOD and M-pIOD indices.





```{r load_data}
setwd("~/CO_AUS/Aus_CO-main")

load( "ne_data.rda")
load( "se_data.rda")

load( "bounded_data.rda")
load( "data_matrix.rda")

load( "lag_list.rda")

#Functions
#load in EOF function
source("pIOD/EOF_iod.R")

# Open NetCDF file (OISST data)

#weekly data
nc.OISS <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sst.wkmean.1990-present.nc")

#montly data
nc.OISS.month <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sst.mnmean.nc")

#add in land sea mask
nc.lsm <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/lsmask.nc")

```



```{r data_cleaning-weekly}
#use this section to determine how this data looks and setup for use
#note we can use the work for OLR here, since OLR data is .nc and setup similarly

#extract lon, lat
lat.grid <- nc.OISS[["dim"]][["lat"]][["vals"]]
lon.grid <- nc.OISS[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid[lon.grid >= 180] <- lon.grid[lon.grid >= 180] - 360
this.order <- order(lon.grid)

lon.grid <- lon.grid[this.order]

#time data
times <- ncvar_get(nc.OISS, "time") # days since 1800-01-01 00:00:0.0
times <- as_datetime("1800-01-01T00:00:00") + days(times)

#sst data, as array (lon, lat, time)
sst <- ncvar_get(nc.OISS, "sst")
sst <- sst[this.order, , ]

```

```{r monthly}
#extract lon, lat
lat.grid.month <- nc.OISS.month[["dim"]][["lat"]][["vals"]]
lon.grid.month <- nc.OISS.month[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.month[lon.grid.month >= 180] <- lon.grid.month[lon.grid.month >= 180] - 360
this.order <- order(lon.grid.month)

lon.grid.month <- lon.grid.month[this.order]

#time data
times.month <- ncvar_get(nc.OISS.month, "time") # days since 1800-01-01 00:00:0.0
times.month <- as_datetime("1800-01-01T00:00:00") + days(times.month)


#sst data, as array (lon, lat, time)
sst.month <- ncvar_get(nc.OISS.month, "sst")
sst.month <- sst.month[this.order, , ]

```



```{r IOD_bounds}
#set IOD boundary points (from Cai et al 2021)
IOD_maxLon <- 100
IOD_minLon <- 40
IOD_maxLat <- 5
IOD_minLat <- -5

#IOD boundary as vector
IOD.lon.range <- c(IOD_minLon, IOD_maxLon)
IOD.lat.range <- c(IOD_minLat, IOD_maxLat) 

#get value in the boundary range
lat.values <- lat.grid[lat.grid <= IOD_maxLat & lat.grid >= IOD_minLat]
lat.range <- range(which(lat.grid <= IOD_maxLat & lat.grid >= IOD_minLat))

lon.values <- lon.grid[lon.grid <= IOD_maxLon & lon.grid >= IOD_minLon]
lon.range <- range(which(lon.grid <= IOD_maxLon & lon.grid >= IOD_minLon))

#date (time) bounds (weeks)
times[523] #2000-01-02 (week 1) (we need +1 year)
times[471] #1999-01-03 for 12 month (52 week) climatology
times[1579] #2020-03-29 (week 14)

times[1556] #"2019-10-20 UTC"

#TODO: determine the weeks for SON (and DJF)

#get sst for IOD only (and time range)
sst_IOD <- sst[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2], 523:1579] 


#TODO: update to combine week 53 with 52, when present
times[which(epiweek(times)==53)]

temp_week <- epiweek(times[523:1579])
week53 <- which(temp_week == 53)

sst_IOD[,,260]

#avg and re-assign week 52
for (i in week53) {
  mat1 <- sst_IOD[,,i-1]
  mat2 <- sst_IOD[,,i]
  sst_IOD[,,i-1] <- (mat1 + mat2)/2
}


#TODO: delete week 53s after
sst_IOD <- sst_IOD[,,-c(week53)]

#wider viz range #xlim = c(30, 110), ylim = c(-20,20)
viz_maxLon <- 110
viz_minLon <- 30
viz_maxLat <- 20
viz_minLat <- -20

lat.values.viz <- lat.grid[lat.grid <= viz_maxLat & lat.grid >= viz_minLat]
lat.range.viz <- range(which(lat.grid <= viz_maxLat & lat.grid >= viz_minLat))

lon.values.viz <- lon.grid[lon.grid <= viz_maxLon & lon.grid >= viz_minLon]
lon.range.viz <- range(which(lon.grid <= viz_maxLon & lon.grid >= viz_minLon))



#time bounds for month data
times.month[218] #2000-01-01 (month 1) (we need +1 year)
times.month[206] #1999-01-01 for 12 month (52 week) climatology
times.month[461]  #2020-04-01 (month 4)





```



```{r lsm}
#TODO: setup lsm data from the oisst that aligns with our other data sets
#extract lon, lat
lat.grid.lsm <- nc.lsm[["dim"]][["lat"]][["vals"]]
lon.grid.lsm <- nc.lsm[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.lsm[lon.grid.lsm >= 180] <- lon.grid.lsm[lon.grid.lsm >= 180] - 360
this.order.lsm <- order(lon.grid.lsm)

lon.grid.lsm <- lon.grid.lsm[this.order.lsm]


#setup (or find) a land sea mask.
lsm <- ncvar_get(nc.lsm, "mask")
lsm <- lsm[this.order.lsm, ]

#TODO update lsm for reduced region
#get lsm for IOD only
lsm_IOD <- lsm[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2]] 


```


```{r masking_test}
sst_test <- sst[ , ,1250]

times[1250]

sst_test2 <- sst_test[lon.range.viz[1]:lon.range.viz[2], lat.range.viz[1]:lat.range.viz[2]] 
test_range <- range(sst_test2)
test_rangebase <- range(sst_test)

#ls mask
sst.lsm <- sst_test * lsm[ ,ncol(lsm):1]

```

```{r SON_DJF}
#get reduced time scale
```


# EOF


```{r }

```


Question: do we pass in standardized data? (Yes?)

```{r EOF_setup}
##A is monthly field data array (not anom data) as [time, y, x] or [time, lat, lon]
dim(sst_IOD)

A <- aperm(sst_IOD, perm = c(3,2,1)) #[time, lat, lon]


#sst_IOD is already as [lon, lat, time] (or [nx, ny, nt])
## -therefore the above re-order needs to be [ny, nx, nt]
Q_net <- aperm(sst_IOD, perm = c(2, 1, 3))

```


```{r EOF_function_test}
#TODO: test the EOF function from cai et al
#from matlab code:
##A is monthly field data array (not anom data) as [time, y, x] or [time, lat, lon]
##kMod is number of modes (note sure what htis means)
##aMod is anom data setup, 12 month or all climatology

#matlab code:
##Q_net=A; #assign array A to Q_net

#TODO: rewrite 
Q_net <- sst_IOD #as[nx, ny, nt] 

# Get dimensions [nx, ny, nt]
dims <- dim(Q_net)
nx <- dims[1]
ny <- dims[2]
nt <- dims[3]

#TODO: update so that we don't need all this when we could just change the numbers in the above dimensions
# Reorder from [nx, ny, nt] to [ny, nx, nt] like in MATLAB loop
Q_net_1 <- aperm(Q_net, perm = c(2, 1, 3))  # Now [ny, nx, nt]
  
# Overwrite Q_net and clear Q_net_1
Q_net <- Q_net_1
rm(Q_net_1)

# Flatten spatial dimensions: [ny*nx, nt]
np <- nx * ny
var <- matrix(Q_net, nrow = np, ncol = nt)

# Get remainder when nt is divided by 52 (weeks in a year)
nn <- nt %% 52

#or 12 for month data
##nn <- nt %% 12


#anomaly (yearly)
week_mean <- matrix(NA, nrow = np, ncol = 52)

#TODO: adjust for loop when we move this over
for (j in 1:52) {
  # Find all time indices corresponding to week `j`
  cols_j <- seq(j, nt, by = 52)
      
  # Compute weekly mean across years for each spatial point
  week_mean[ ,j] <- rowMeans(var[, cols_j, drop = FALSE])
  
  # Number of time points this week occurs in
  ncols <- length(cols_j)
      
  # Subtract weekly mean
  var[, cols_j] <- var[, cols_j] - matrix(week_mean[, j], nrow = np, ncol = ncols)
}


#update from LSM (same as the NaN section in EOF.m)
# 1. Flatten mask [nx, ny] -> vector [np]
lsm_vec <- as.vector(lsm_IOD)  

# 2. Keep only ocean points: where mask == 1
is_ocean <- lsm_vec == 1
var_masked <- var[is_ocean, ]

var_eof <- var_masked

which(is.na(var_eof))
```


```{r plot_anoms}
times[522+728]

#726 (1250)

# Step 1: Convert var [ny*nx, nt] back to [ny, nx, nt]
temp <- array(t(var), dim = c(nt, ny, nx))  # t(var) is [nt, ny*nx]
Q_net_1 <- aperm(temp, c(2, 3, 1))  # [ny, nx, nt]

# Step 2: Reverse the earlier aperm to get back to [nx, ny, nt]
anom_matrix <- aperm(Q_net_1, c(2, 1, 3))
anom_matrix <- anom_matrix[,,1031]



lsm_IOD <- lsm[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2]] 
#lsm_IOD[lsm_IOD == 0] <- 5 

z_range <- range(anom_matrix)

#ls mask
anom_matrix <- anom_matrix * lsm_IOD[ ,ncol(lsm_IOD):1]
anom_matrix[anom_matrix == 0] <- -5 


#anom_matrix <- matrix(Q_net_reconstructed[ , ,728], nrow = nx, ncol = ny)
#eof1_matrix <- eof1_matrix[ ,ny:2]

image.plot(list(x = lon.values, y = rev(lat.values), z = anom_matrix), zlim  = z_range)
world(add = TRUE)


setwd("~/CO_AUS/Aus_CO-main/pIOD/Figures")

#surface
png(filename = "IODsst_anom1.png", width = 2400, height = 1000, res = 300)
par(mar = c(5, 5, 3, 6))
image.plot(list(x = lon.values, y = rev(lat.values), z = anom_matrix), zlim  = z_range, col = tim.colors(256),
           xlim = c(40, 100), ylim = c(-5, 5), xlab = "Lon", ylab = "Lat")
title("SST Anomalies from week of October 20, 2019", adj = 0)
world(add = T)
dev.off()

```

```{r test_plot}
#compare var and original data
#sst_IOD #as[nx, ny, nt]
dim(sst_IOD)
sst_IOD_new <- sst_IOD[,,1031]

sst_range <- range(sst_IOD_new)

#ls mask
sst_IOD_new <- sst_IOD_new * lsm_IOD[ ,ncol(lsm_IOD):1]
sst_IOD_new[sst_IOD_new == 0] <- -5 

#var transform from [ny*nx, nt] back to [ny, nx, nt]
temp <- array(t(var), dim = c(nt, ny, nx))  # t(var) is [nt, ny*nx]
Q_net_1 <- aperm(temp, c(2, 3, 1))  # [ny, nx, nt]

# Step 2: Reverse the earlier aperm to get back to [nx, ny, nt]
anom_matrix <- aperm(Q_net_1, c(2, 1, 3))
anom_matrix <- anom_matrix[,,1031]



lsm_IOD <- lsm[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2]] 
#lsm_IOD[lsm_IOD == 0] <- 5 

z_range <- range(anom_matrix)

#ls mask
anom_matrix <- anom_matrix * lsm_IOD[ ,ncol(lsm_IOD):1]
anom_matrix[anom_matrix == 0] <- -5 


#anom_matrix <- matrix(Q_net_reconstructed[ , ,728], nrow = nx, ncol = ny)
#eof1_matrix <- eof1_matrix[ ,ny:2]

image.plot(list(x = lon.values, y = rev(lat.values), z = anom_matrix), zlim  = z_range)
world(add = TRUE)


image.plot(list(x = lon.values, y = rev(lat.values), z = sst_IOD_new), zlim = sst_range)
world(add = TRUE)
```


```{r further_anom_tests}
#double checking code for anomalies
np <- nx * ny
var <- matrix(Q_net, nrow = np, ncol = nt)

# Get remainder when nt is divided by 52 (weeks in a year)
nn <- nt %% 52

#or 12 for month data
##nn <- nt %% 12


#anomaly (yearly)
weekly_mean <- matrix(NA, nrow = np, ncol = 52)

j <- 1
# Find all time indices corresponding to week `j`
cols_j <- seq(j, nt, by = 52)

```


## PCA (EOF) 

Base matlab code for eigen decomp
[V1,E]=eig(var_eof'*var_eof);
E=fliplr(flipud(E));
V2=fliplr(var_eof*V1);

```{r eof_pca}
#modified code from MATLAB EOF.m

kmod <- 2



# Assume var_eof is [nspace, ntime] and kmod is the number of modes
# Compute covariance matrix in time
cov_mat <- t(var_eof) %*% var_eof

# Eigen-decomposition (EVD of "cov matrix")
eig <- eigen(cov_mat, symmetric = TRUE)

#corrected section
E <- eig$values

V1 <- eig$vectors
V2 <- var_eof %*% V1


#brief test for centered data
var_center <- scale(var_eof, center = TRUE, scale = TRUE)

cov_test <- t(var_center) %*% var_center

# Eigen-decomposition (EVD of "cov matrix")
eig_test <- eigen(cov_test, symmetric = TRUE)


# Initialize matrices
V <- matrix(NA, nrow = nrow(V2), ncol = kmod)
PC <- matrix(NA, nrow = ncol(var_eof), ncol = kmod)
per <- numeric(kmod)



# Loop through first kmod modes
for (i in 1:kmod) {
  V[, i] <- V2[, i] / sqrt(E[i])              # EOF mode
  PC[, i] <- as.vector(t(V[, i]) %*% var_eof)      # Principal components (this should be var_eof %*% V, since XV = UD)
  per[i] <- E[i] / sum(E)                # Variance explained
}

EOF_mode <- V

```


```{r svd}

#TODO: center var_eof first (X has to be centered)
svd_test <- svd(scale(var_eof, center = TRUE, scale = FALSE))

#svd outputs
U <- svd_test$u[ ,1:kmod]
D <- svd_test$d[1:kmod]
V <- svd_test$v[ ,1:kmod]

#test outputs
EOF_test <- U #EOF spatial pattern
PC_test <- V %*% diag(D)
per_test <- D^2 / sum(svd_test$d^2) 

```


```{r prcomp}
#test for prcomp
pca <- prcomp(t(var_eof), center = TRUE, scale. = FALSE )


#EOF spatial [np, kmod]
pc_EOF <- pca$rotation[, 1:kmod]

#pca time series
pc_ts <- pca$x[, 1:kmod]

matplot(pc_ts[, 1], type = "l", lty = 1, lwd = 2,
        xlab = "Time", ylab = "Principal Component")

matplot(pc_ts[, 2], type = "l", lty = 1, lwd = 2,
        xlab = "Time", ylab = "Principal Component")

per <- pca$sdev[1:15]^2 / sum(pca$sdev^2)

plot(per[1:6] * 100, type = "b", pch = 19,
     xlab = "Component", ylab = "Variance Explained (%)", ylim = c(0,50))

```


```{r plots}

dates <- times[523:1579]
temp_week <- epiweek(times[523:1579])
week53 <- which(temp_week == 53)

dates_new <- dates[-week53]

y_range <- range(pc_ts)

setwd("~/CO_AUS/Aus_CO-main/pIOD/Figures")


png(filename = "pct_var.png", width = 2000, height = 1500, res = 300)
par(mar = c(5, 5, 3, 5))
plot(per[1:6] * 100, type = "b", pch = 19,
     xlab = "Component", ylab = "Variance Explained (%)", ylim = c(0,50))
title(" Proportion of Variance Explained", adj = 0)
dev.off()

png(filename = "pc1_ts.png", width = 2400, height = 1200, res = 300)
par(mar = c(5, 5, 3, 5))
plot(dates_new, pc_ts[, 1], type = "l", lty = 1, lwd = 1.82, ylim = y_range,
        xlab = "Year", ylab = "Principal Component")
title("Principle Component 1 (PC1)", adj = 0)
dev.off()

png(filename = "pc2_ts.png", width = 2400, height = 1200, res = 300)
par(mar = c(5, 5, 3, 5))
plot(dates_new, pc_ts[, 2], type = "l", lty = 1, lwd = 1.82, ylim = y_range,
        xlab = "Year", ylab = "Principal Component")
title("Principle Component 2 (PC2)", adj = 0)
dev.off()

```


```{r compare_results}
dim(EOF_test) #svd
dim(pc_EOF) #prcomp
EOF_test[1:10, ]
pc_EOF[1:10, ]

dim(PC_test)
dim(pc_ts)
PC_test[1:10, ]
pc_ts[1:10, ]
```


```{r S_M-Index}

S_ind <- (pc_ts[, 1] + pc_ts[, 2])/sqrt(2)
M_ind <- (pc_ts[, 1] - pc_ts[, 2])/sqrt(2)

index_range <- range(S_ind, M_ind)

setwd("~/CO_AUS/Aus_CO-main/pIOD/Figures")

png(filename = "strong.png", width = 2400, height = 1200, res = 300)
par(mar = c(5, 5, 3, 5))
plot(dates_new, S_ind, type = "l", lty = 1, lwd = 1.8, ylim = index_range,
        xlab = "Year", ylab = "Index")
abline(h = 0, lty = 2, col = "red")
title("S-Index", adj = 0)
dev.off()

png(filename = "moderate.png", width = 2400, height = 1200, res = 300)
par(mar = c(5, 5, 3, 5))
plot(dates_new, M_ind, type = "l", lty = 1, lwd = 1.8, ylim = index_range,
        xlab = "Year", ylab = "Index")
abline(h = 0, lty = 2, col = "red")
title("M-Index", adj = 0)
dev.off()

```


```{r reintroduce_land}
V_new <- matrix(NA, nrow = np, ncol = kmod)

#add in lsm sea data
V_new[lsm_vec == 1, ] <- pc_EOF
```


# Visualizations

```{r bubbleplot}
grid.list <- list(x = lon.grid,
                  y = rev(lat.grid))

s.grid <- make.surface.grid(grid.list)

z.grid <- as.vector(sst.lsm)

sst.df <- data.frame(s.grid, z = z.grid)

#test block
image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), col = tim.colors(256), zlim  = z_range,
           xlim = c(40, 100), ylim = c(-5, 5), xlab = "Lon", ylab = "Lat",
           legend.args =list(text = expression(degree * C), side = 1, line = 1.25))
title("SST from week of December 8, 2013", adj = 0)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "black", lwd = 2.5)


setwd("~/CO_AUS/Aus_CO-main/pIOD/Figures")

#surface
png(filename = "IODsst_test2.png", width = 2000, height = 1500, res = 300)
par(mar = c(5, 5, 3, 6))
image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), col = tim.colors(256), zlim  = test_range,
           xlim = c(30, 110), ylim = c(-20, 20), xlab = "Lon", ylab = "Lat",
           legend.args =list(text = expression(degree * C), side = 1, line = 1.25))
title("SST from week of December 8, 2013", adj = 0)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "black", lwd = 2.5)
dev.off()

#bubble plot (point)
png(filename = "IODsst_test.png", width = 2000, height = 1500, res = 300)
par(mar = c(5, 5, 3, 6))
bubblePlot(sst.df$x, sst.df$y, sst.df$z, col = tim.colors(256), size = 0.75, zlim  = test_range,
           xlim = c(30, 110), ylim = c(-20,20), xlab = "Lon", ylab = "Lat",legend.args =list(text = expression(degree * C), side = 1, line = 1.25))
title("SST from week of December 8, 2013", adj = 0)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "black", lwd = 2.5)
dev.off()

```

## Anomalies (1 year climatology)

Get from the EOF function

```{r }

```


## PCA 

```{r spatial_EOF}
#spatial patterns from EOFs

eof1_matrix <- matrix(V_new[, 2], nrow = nx, ncol = ny)
eof1_matrix <- eof1_matrix[ ,ny:2]

image.plot(list(x = lon.values, y = rev(lat.values), z = eof1_matrix))


matplot(PC_test[, 2], type = "l", lty = 1, lwd = 2,
        xlab = "Time", ylab = "Principal Component")



```


## Old (delete later)

```{r test_image}
#times[1250]
sst_test <- sst[ , ,1250]
image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), asp = 1, col = tim.colors(256),
           bty = "n", xaxt = "n", yaxt = "n")
world(add = T)

image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), asp = 1, col = tim.colors(256),
           bty = "n", xaxt = "n", yaxt = "n", xlim = c(30, 110), ylim = c(-20,20),  zlim = test_range)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "magenta3", lwd = 2)

```

