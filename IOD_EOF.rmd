---
title: "IOD_EOF"
author: "Ryan Peterson"
date: "2025-07-16"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
#.nc files
library(ncdf4)
suppressMessages(library(terra))

# date mgmt
suppressMessages(library(lubridate))

#visualization and interpolation
suppressMessages(library(fields))

```

The goal of this document is to reproduce the pIOD indices from Cai et al, 2021

Starting with OISST v2 (NOAA Optimum Interpolation SST version 2)

From .nc data we clean and sort data correctly, the perform appropriate EOF(PCA), then get S-pIOD and M-pIOD indices.





```{r load_data}
setwd("~/CO_AUS/Aus_CO-main")

load( "ne_data.rda")
load( "se_data.rda")

load( "bounded_data.rda")
load( "data_matrix.rda")

load( "lag_list.rda")

# Open NetCDF file (OISST data)

#weekly data
nc.OISS <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sst.wkmean.1990-present.nc")

#montly data
nc.OISS.month <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/sst.mnmean.nc")

#add in land sea mask
nc.lsm <- nc_open("~/CO_AUS/Aus_CO-main/pIOD/Data/lsmask.nc")

```



```{r data_cleaning-weekly}
#use this section to determine how this data looks and setup for use
#note we can use the work for OLR here, since OLR data is .nc and setup similarly

#extract lon, lat
lat.grid <- nc.OISS[["dim"]][["lat"]][["vals"]]
lon.grid <- nc.OISS[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid[lon.grid >= 180] <- lon.grid[lon.grid >= 180] - 360
this.order <- order(lon.grid)

lon.grid <- lon.grid[this.order]

#time data
times <- ncvar_get(nc.OISS, "time") # days since 1800-01-01 00:00:0.0
times <- as_datetime("1800-01-01T00:00:00") + days(times)

#sst data, as array (lon, lat, time)
sst <- ncvar_get(nc.OISS, "sst")
sst <- sst[this.order, , ]

```

```{r monthly}
#extract lon, lat
lat.grid.month <- nc.OISS.month[["dim"]][["lat"]][["vals"]]
lon.grid.month <- nc.OISS.month[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.month[lon.grid.month >= 180] <- lon.grid.month[lon.grid.month >= 180] - 360
this.order <- order(lon.grid.month)

lon.grid.month <- lon.grid.month[this.order]

#time data
times.month <- ncvar_get(nc.OISS.month, "time") # days since 1800-01-01 00:00:0.0
times.month <- as_datetime("1800-01-01T00:00:00") + days(times.month)


#sst data, as array (lon, lat, time)
sst.month <- ncvar_get(nc.OISS.month, "sst")
sst.month <- sst.month[this.order, , ]

```



```{r IOD_bounds}
#set IOD boundary points (from Cai et al 2021)
IOD_maxLon <- 100
IOD_minLon <- 40
IOD_maxLat <- 5
IOD_minLat <- -5

#IOD boundary as vector
IOD.lon.range <- c(IOD_minLon, IOD_maxLon)
IOD.lat.range <- c(IOD_minLat, IOD_maxLat) 

#get value in the boundary range
lat.values <- lat.grid[lat.grid <= IOD_maxLat & lat.grid >= IOD_minLat]
lat.range <- range(which(lat.grid <= IOD_maxLat & lat.grid >= IOD_minLat))

lon.values <- lon.grid[lon.grid <= IOD_maxLon & lon.grid >= IOD_minLon]
lon.range <- range(which(lon.grid <= IOD_maxLon & lon.grid >= IOD_minLon))

#date (time) bounds (weeks)
times[523] #2000-01-02 (week 1) (we need +1 year)
times[471] #1999-01-03 for 12 month (52 week) climatology
times[1579] #2020-03-29 (week 14)

#get sst for IOD only (and time range)
sst_IOD <- sst[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2], 471:1579] 

#TODO: update to combine week 53 with 52, when present
times[which(epiweek(times)==53)]

temp_week <- epiweek(times[471:1579])
week53 <- which(temp_week == 53)

sst_IOD[,,260]

#avg and re-assign week 52
for (i in week53) {
  mat1 <- sst_IOD[,,i-1]
  mat2 <- sst_IOD[,,i]
  sst_IOD[,,i-1] <- (mat1 + mat2)/2
}


#TODO: delete week 53s after
sst_IOD <- sst_IOD[,,-c(week53)]

#wider viz range #xlim = c(30, 110), ylim = c(-20,20)
viz_maxLon <- 110
viz_minLon <- 30
viz_maxLat <- 20
viz_minLat <- -20

lat.values.viz <- lat.grid[lat.grid <= viz_maxLat & lat.grid >= viz_minLat]
lat.range.viz <- range(which(lat.grid <= viz_maxLat & lat.grid >= viz_minLat))

lon.values.viz <- lon.grid[lon.grid <= viz_maxLon & lon.grid >= viz_minLon]
lon.range.viz <- range(which(lon.grid <= viz_maxLon & lon.grid >= viz_minLon))



#time bounds for month data
times.month[218] #2000-01-01 (month 1) (we need +1 year)
times.month[206] #1999-01-01 for 12 month (52 week) climatology
times.month[461]  #2020-04-01 (month 4)
```



```{r lsm}
#TODO: setup lsm data from the oisst that aligns with our other data sets
#extract lon, lat
lat.grid.lsm <- nc.lsm[["dim"]][["lat"]][["vals"]]
lon.grid.lsm <- nc.lsm[["dim"]][["lon"]][["vals"]]

#reorder lon for 
lon.grid.lsm[lon.grid.lsm >= 180] <- lon.grid.lsm[lon.grid.lsm >= 180] - 360
this.order.lsm <- order(lon.grid.lsm)

lon.grid.lsm <- lon.grid.lsm[this.order.lsm]


#setup (or find) a land sea mask.
lsm <- ncvar_get(nc.lsm, "mask")
lsm <- lsm[this.order.lsm, ]

#TODO update lsm for reduced region
#get lsm for IOD only
lsm_IOD <- lsm[lon.range[1]:lon.range[2], lat.range[1]:lat.range[2]] 


```


```{r masking_test}
sst_test <- sst[ , ,1250]

times[1250]

sst_test2 <- sst_test[lon.range.viz[1]:lon.range.viz[2], lat.range.viz[1]:lat.range.viz[2]] 
test_range <- range(sst_test2)
test_rangebase <- range(sst_test)

#ls mask
sst.lsm <- sst_test * lsm[ ,ncol(lsm):1]

```


```{r reduced_area}



```


# EOF


```{r EOF_setup}
##A is monthly field data array (not anom data) as [time, y, x] or [time, lat, lon]
dim(sst_IOD)

A <- aperm(sst_IOD, perm = c(3,2,1)) #[time, lat, lon]


#sst_IOD is already as [lon, lat, time] (or [nx, ny, nt])
## -therefore the above re-order needs to be [ny, nx, nt]
Q_net <- aperm(sst_IOD, perm = c(2, 1, 3))

```


```{r EOF_function_test}
#TODO: test the EOF function from cai et al
#from matlab code:
##A is monthly field data array (not anom data) as [time, y, x] or [time, lat, lon]
##kMod is number of modes (note sure what htis means)
##aMod is anom data setup, 12 month or all climatology

#matlab code:
##Q_net=A; #assign array A to Q_net

#TODO: rewrite 
Q_net <- sst_IOD #as[nx, ny, nt] 

# Get dimensions [nx, ny, nt]
dims <- dim(Q_net)
nx <- dims[1]
ny <- dims[2]
nt <- dims[3]

#TODO: update so that we don't need all this when we could just change the numbers in the above dimensions
# Reorder from [nx, ny, nt] to [ny, nx, nt] like in MATLAB loop
Q_net_1 <- aperm(Q_net, perm = c(2, 1, 3))  # Now [ny, nx, nt]
  
# Overwrite Q_net and clear Q_net_1
Q_net <- Q_net_1
rm(Q_net_1)

# Flatten spatial dimensions: [ny*nx, nt]
np <- nx * ny
var <- matrix(Q_net, nrow = np, ncol = nt)

# Get remainder when nt is divided by 52 (weeks in a year)
nn <- nt %% 52

#or 12 for month data
##nn <- nt %% 12


#anomaly (yearly)
week_mean <- matrix(NA, nrow = np, ncol = 52)

#TODO: adjust for loop when we move this over
for (j in 1:52) {
  # Find all time indices corresponding to week `j`
  cols_j <- seq(j, nt, by = 52)
      
  # Compute weekly mean across years for each spatial point
  week_mean[ ,j] <- rowMeans(var[, cols_j, drop = FALSE])
  
  # Number of time points this week occurs in
  ncols <- length(cols_j)
      
  # Subtract weekly mean
  var[, cols_j] <- var[, cols_j] - matrix(week_mean[, j], nrow = np, ncol = ncols)
}


#update from LSM (same as the NaN section in EOF.m)
# 1. Flatten mask [nx, ny] -> vector [np]
lsm_vec <- as.vector(lsm_IOD)  

# 2. Keep only ocean points: where mask == 1
is_ocean <- lsm_vec == 1
var_masked <- var[is_ocean, ]

var_eof <- var_masked

```

## PCA (EOF) 

```{r eof_pca}
#modified code from MATLAB EOF.m

# Assume var_eof is [nspace, ntime] and kmod is the number of modes
# Compute covariance matrix in time
cov_mat <- t(var_eof) %*% var_eof

# Eigen-decomposition (EVD of "cov matrix")
eig <- eigen(cov_mat, symmetric = TRUE)



#TODO: finish this up and compare to svd() (base R)

```



# Visualizations

```{r bubbleplot}
grid.list <- list(x = lon.grid,
                  y = rev(lat.grid))

s.grid <- make.surface.grid(grid.list)

z.grid <- as.vector(sst.lsm)

sst.df <- data.frame(s.grid, z = z.grid)


setwd("~/CO_AUS/Aus_CO-main/pIOD/Figures")

#surface
png(filename = "IODsst_test2.png", width = 2000, height = 1500, res = 300)
par(mar = c(5, 5, 3, 6))
image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), col = tim.colors(256), zlim  = test_range,
           xlim = c(30, 110), ylim = c(-20, 20), xlab = "Lon", ylab = "Lat",
           legend.args =list(text = expression(degree * C), side = 1, line = 1.25))
title("SST from week of August 12, 2013", adj = 0)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "black", lwd = 2.5)
dev.off()

#bubble plot (point)
png(filename = "IODsst_test.png", width = 2000, height = 1500, res = 300)
par(mar = c(5, 5, 3, 6))
bubblePlot(sst.df$x, sst.df$y, sst.df$z, col = tim.colors(256), size = 0.75, zlim  = test_range,
           xlim = c(30, 110), ylim = c(-20,20), xlab = "Lon", ylab = "Lat",legend.args =list(text = expression(degree * C), side = 1, line = 1.25))
title("SST from week of August 12, 2013", adj = 0)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "black", lwd = 2.5)
dev.off()

```



```{r test_image}
#times[1250]
sst_test <- sst[ , ,1250]
image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), asp = 1, col = tim.colors(256),
           bty = "n", xaxt = "n", yaxt = "n")
world(add = T)

image.plot(list(x = lon.grid, y = rev(lat.grid), z = sst.lsm), asp = 1, col = tim.colors(256),
           bty = "n", xaxt = "n", yaxt = "n", xlim = c(30, 110), ylim = c(-20,20),  zlim = test_range)
world(add = T)
rect(IOD_minLon, IOD_minLat, IOD_maxLon, IOD_maxLat, border = "magenta3", lwd = 2)

```

